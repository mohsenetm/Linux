سیستم‌عامل به‌عنوان یک رابط (Interface) عمل می‌کند که به کاربر امکان تعامل با سخت‌افزار و هسته سیستم‌عامل (Kernel) را می‌دهد.

## کرنل (Kernel)

هسته یا کرنل بخش مرکزی سیستم‌عامل است که مسئول مدیریت منابع سخت‌افزاری و ارتباط میان اجزای مختلف آن است. کرنل به‌عنوان یک لایه میانی، ارتباط بین نرم‌افزار و سخت‌افزار را برقرار می‌کند و عملیات سطح پایین رایانه را کنترل می‌کند. وظایف اصلی کرنل عبارت‌اند از:

**مدیریت پردازنده (CPU)**

**مدیریت حافظه (RAM)** 

**مدیریت دستگاه‌ها** 

**مدیریت فایل‌ها** 

**امنیت و کنترل دسترسی** 

## لینوکس: کرنل یا سیستم‌عامل؟

لینوکس در واقع یک کرنل است، نه یک سیستم‌عامل کامل. این کرنل توسط لینوس توروالدز در سال 1991 توسعه یافت و به‌مرور زمان تکامل پیدا کرد. برای تبدیل کرنل لینوکس به یک سیستم‌عامل کامل، اجزای دیگری مانند ابزارها، کتابخانه‌ها، و رابط‌های کاربری به آن اضافه می‌شوند که توسط توزیع‌های مختلف لینوکس (مانند اوبونتو، فدورا، و دبیان) ارائه می‌شوند. به همین دلیل، وقتی از لینوکس صحبت می‌شود، اغلب منظور توزیع‌های سیستم‌عامل مبتنی بر کرنل لینوکس است.

------

## دسته‌بندی‌های لینوکس:

لینوکس، به‌عنوان یک کرنل متن‌باز، در قالب توزیع‌های مختلفی عرضه می‌شود که هرکدام ویژگی‌ها و قابلیت‌های خاص خود را دارند. این توزیع‌ها بر اساس نحوه مدیریت بسته‌ها (Package Manager) و معماری پایه خود دسته‌بندی می‌شوند. دو دسته‌بندی اصلی و پرکاربرد لینوکس به شرح زیر است:

## 1. دسته‌بندی Debian

توزیعات مشهور:

###### Ubuntu

###### Linux Mint

###### Elementary OS

مدیر بسته:

توزیع‌های مبتنی بر Debian از مدیر بسته DEB استفاده می‌کنند. ابزارهای مدیریت بسته معروف در این توزیع‌ها عبارت‌اند از:

`apt`: برای نصب، حذف، و به‌روزرسانی بسته‌ها. => این پکیج منیجر بسته ها را از اینترنت دریافت می کند.

`dpkg`: ابزار سطح پایین برای مدیریت بسته‌ها. => این پکیج منیجر تنها امکان نصب از روی فایل را دارد و نمی تواند بسته را به صورت اتوماتیک از اینترنت دانلود کند.

## 2. دسته‌بندی Fedora

توزیعات مشهور:

CentOS (اکنون Rocky Linux و AlmaLinux جایگزین آن شده‌اند)

Red Hat Enterprise Linux (RHEL)

Fedora Workstation

مدیر بسته:

این توزیع‌ها از مدیر بسته RPM (Red Hat Package Manager) استفاده می‌کنند. ابزارهای مدیریت بسته محبوب در این دسته عبارت‌اند از:

`dnf` یا `yum`: برای نصب، حذف، و به‌روزرسانی بسته‌ها. => این پکیج منیجر بسته ها را از اینترنت دریافت می کند

`rpm`: ابزار سطح پایین برای مدیریت بسته‌ها. => این پکیج منیجر تنها امکان نصب از روی فایل را دارد و نمی تواند بسته را به صورت اتوماتیک از اینترنت دانلود کند.

------

## مفهوم نسخه‌بندی در توزیع‌های لینوکس

یکی از ویژگی‌های متمایز برخی از توزیع‌های لینوکس، نحوه مدیریت نسخه‌ها یا **Release** آن‌هاست. دو نوع کلی وجود دارد:

**Standard Release (انتشار استاندارد):**
این نوع توزیع‌ها نسخه‌های مشخصی دارند که در بازه‌های زمانی منظم منتشر می‌شوند. به‌عنوان مثال:

اوبونتو هر 6 ماه یک نسخه عادی (Standard Release) و هر 2 سال یک نسخه LTS (Long-Term Support) منتشر می‌کند.

**Rolling Release (انتشار پیوسته):**
در این مدل، توزیع نسخه‌های مشخصی ندارد. به‌جای آن، سیستم به‌طور مداوم به‌روزرسانی می‌شود. این به‌روزرسانی‌ها شامل بهبودها و ویژگی‌های جدید است، بدون نیاز به نصب نسخه جدید سیستم‌عامل.

مثال‌ها: Arch Linux، Manjaro.

------

## استفاده از Bash در ویندوز

مایکروسافت با معرفی Windows Subsystem for Linux (WSL)، امکان استفاده از ابزارها و محیط لینوکس را مستقیماً در ویندوز فراهم کرده است.

اگر در ویندوز عبارت **`bash`** را در Command Prompt یا PowerShell تایپ کنید، وارد خط فرمان لینوکس می‌شوید.

این قابلیت به توسعه‌دهندگان اجازه می‌دهد تا از ابزارهای لینوکس، اسکریپت‌ها و حتی برنامه‌های سرور بدون نیاز به ماشین مجازی یا دوال‌بوت استفاده کنند.

------

```
FTP: 20,21
SSH: 22
HTTP: 80
HTTPS: 443
```

------

## بررسی پورت‌ها در فایل `/etc/services`

در سیستم‌عامل‌های مبتنی بر لینوکس و یونیکس، فایل **`/etc/services`** شامل لیستی از تمام شماره پورت‌ها و پروتکل‌های مورد استفاده توسط برنامه‌ها و سرویس‌ها است. این فایل اطلاعات زیر را ارائه می‌دهد:

شماره پورت (Port Number)

پروتکل (TCP/UDP)

نام سرویس مرتبط با پورت

برای مثال، یک خط در این فایل ممکن است به این شکل باشد:

```
bash


CopyEdit
http    80/tcp  # World Wide Web HTTP
```

این خط نشان می‌دهد که پورت 80 توسط پروتکل TCP برای سرویس HTTP استفاده می‌شود.

------

### MBR (Master Boot Record)

**MBR** یک ساختار قدیمی و پراستفاده برای پارتیشن‌بندی دیسک‌ها است که مشخصات زیر را دارد:

**حداکثر ظرفیت پشتیبانی:** تنها تا **2 ترابایت** از ظرفیت دیسک را پشتیبانی می‌کند.

ساختار پارتیشن‌بندی:

هر دیسک می‌تواند **4 پارتیشن Primary** داشته باشد.

یکی از این پارتیشن‌ها می‌تواند به‌عنوان **پارتیشن Extended** تعریف شود. این پارتیشن می‌تواند شامل تعداد نامحدودی **پارتیشن Logical** باشد.

**قدمت:** بیش از سه دهه به‌عنوان استاندارد اصلی استفاده می‌شده است.

محدودیت‌ها:

تعداد پارتیشن‌های محدود.

محدودیت ظرفیت دیسک.

پشتیبانی در برخی سیستم‌های قدیمی همچنان رایج است.

------

### GPT (GUID Partition Table)

**GPT** نسل جدیدی از پارتیشن‌بندی است که مشکلات و محدودیت‌های MBR را برطرف می‌کند. ویژگی‌های کلیدی آن عبارت‌اند از:

**حداکثر ظرفیت پشتیبانی:** امکان پشتیبانی از دیسک‌هایی با ظرفیت تا چند میلیارد ترابایت.

ساختار پارتیشن‌بندی:

تا **128 پارتیشن Primary** در هر دیسک.

برخلاف MBR، مفهوم پارتیشن‌های Extended یا Logical در GPT وجود ندارد؛ ساختار آن کاملاً مسطح است.

سازگاری با BIOS و UEFI:

سیستم‌های قدیمی مبتنی بر **BIOS** امکان بوت سیستم‌عامل ویندوز از روی دیسک GPT را ندارند.

اما **UEFI** (جایگزین مدرن BIOS) این محدودیت را ندارد و به‌خوبی از GPT پشتیبانی می‌کند.

**کاربرد در لینوکس:**
لینوکس هیچ محدودیتی در استفاده از GPT، حتی در سیستم‌های مبتنی بر BIOS، ندارد و به‌خوبی از این ساختار پشتیبانی می‌کند.

------

## نرم‌افزارهای پارتیشن‌بندی در لینوکس

برای مدیریت پارتیشن‌ها در لینوکس ابزارهای متنوعی وجود دارد که هرکدام قابلیت‌های خاص خود را دارند:

**`fdisk`:**

پشتیبانی از **MBR**.

از **GPT** پشتیبانی نمی‌کند.

ابزاری ساده و مناسب برای سیستم‌های قدیمی‌تر.

**`libparted`:**

پشتیبانی از هر دو ساختار **MBR** و **GPT**.

ابزاری قدرتمند و انعطاف‌پذیر.

**`gptfdisk`:**

از هر دو ساختار **MBR** و **GPT** پشتیبانی می‌کند.

مناسب برای دیسک‌های حجیم و پیشرفته.

**`gparted`:**

نسخه گرافیکی ابزار پارتیشن‌بندی که مبتنی بر **libparted** است.

از هر دو MBR و GPT پشتیبانی می‌کند.

رابط کاربری ساده و بصری آن، مدیریت پارتیشن‌ها را حتی برای کاربران مبتدی آسان می‌کند.

امکانات: ایجاد، حذف، تغییر اندازه، و فرمت پارتیشن‌ها.

------

## مقایسه BIOS و UEFI

**BIOS:**

سیستم سنتی برای مدیریت فرایند بوت.

محدودیت در پشتیبانی از دیسک‌های بزرگ‌تر از 2 ترابایت.

مناسب برای سیستم‌های مبتنی بر MBR.

**UEFI:**

جایگزین مدرن برای BIOS.

امکان بوت سیستم‌عامل از دیسک‌های GPT.

پشتیبانی از امکانات پیشرفته مانند گرافیک بهتر در محیط بوت و امنیت بیشتر

------

لینوکس برخلاف سیستم‌عامل‌های ویندوز و مک، ساختار درایو مجزا ندارد و همه فایل‌ها و پوشه‌ها در یک ساختار درختی منظم سازماندهی می‌شوند که از دایرکتوری اصلی (Root Directory) با علامت **/** آغاز می‌شود. در این سیستم، تمام دستگاه‌ها و فایل‌ها به عنوان بخشی از این درخت فایل در نظر گرفته می‌شوند.

## فرمت‌های محبوب پارتیشن‌بندی در لینوکس

در لینوکس، برای مدیریت و استفاده از فضای دیسک، پارتیشن‌ها با فرمت‌های مختلفی قابل پیکربندی هستند. از میان این فرمت‌ها، برخی رایج‌تر و پرکاربردتر هستند:

#### 1. **EXT3**

این فرمت یکی از نسخه‌های قدیمی سیستم فایل لینوکس است که توانایی پشتیبانی از حجم‌های تا **2 ترابایت** را دارد. این سیستم فایل از سال 2010 معرفی شد و با ارائه قابلیت‌هایی نظیر ثبت تراکنش‌ها (Journaling)، بهبود پایداری و جلوگیری از خرابی داده‌ها را به همراه داشت.

#### 2. **EXT4**

نسخه ارتقایافته سیستم فایل EXT3 که توانایی پشتیبانی از حجم‌های بسیار بزرگ‌تر تا **16 ترابایت** را دارد. این فرمت مدرن‌تر است و با بهبود عملکرد و افزایش کارایی برای حجم‌های بزرگتر، به یکی از گزینه‌های اصلی پارتیشن‌بندی در لینوکس تبدیل شده است.

## نمایش پارتیشن‌ها در لینوکس

در لینوکس، هر پارتیشن موجود روی دیسک سخت به صورت یک دستگاه (Device) در مسیر **/dev/** نمایش داده می‌شود. برای مثال:

دیسک اصلی سیستم ممکن است با نام **/dev/sda** نمایش داده شود.

پارتیشن‌های روی این دیسک به ترتیب شماره‌گذاری می‌شوند:

```
/dev/sda1
/dev/sda2
```

این شماره‌ها نشان‌دهنده موقعیت پارتیشن‌ها روی دیسک هستند.

اگر یک دیسک سخت جدید به سیستم اضافه کنید، لینوکس آن را به صورت یک دستگاه جدید شناسایی می‌کند. برای مثال، دیسک دوم با نام **/dev/sdb** نمایش داده خواهد شد.

## فرآیند استفاده از پارتیشن‌ها

برای استفاده از پارتیشن‌های جدید، ابتدا باید آن‌ها را **مونت (Mount)** کنید. مونت کردن به معنای متصل کردن پارتیشن به یک دایرکتوری خاص در سیستم فایل است. به این ترتیب، فایل‌ها و پوشه‌های پارتیشن مورد نظر از طریق آن دایرکتوری قابل دسترسی خواهند بود.

## استفاده اولیه از لینوکس

هنگامی که برای اولین بار **ترمینال لینوکس** را باز می‌کنید، پیش از وارد کردن دستورات، خطی شبیه به نمونه زیر مشاهده می‌کنید:

```
mohsen@F1274:~$
```

این خط به اجزای زیر تقسیم می‌شود:

**mohsen**: نام کاربری که در حال حاضر وارد سیستم شده است.

**F1274**: نام کامپیوتر یا میزبان (hostname).

**~**: نشان‌دهنده دایرکتوری خانگی (home directory) کاربر است.

**$**: نشان می‌دهد که شما با سطح دسترسی کاربر عادی وارد شده‌اید.

**#**: اگر به جای `$` علامت `#` را ببینید، نشان‌دهنده سطح دسترسی کاربر **root** یا مدیر سیستم است.

## بررسی دایرکتوری خانگی

با وارد کردن `~` در ترمینال، مسیر دایرکتوری خانگی کاربر فعلی نمایش داده می‌شود. به طور پیش‌فرض، دایرکتوری خانگی مکانی است که فایل‌ها و تنظیمات شخصی کاربر ذخیره می‌شوند.

### **ساختار کلی کامند در لینوکس**

در **لینوکس**، هر دستور (Command) از چندین بخش تشکیل شده است. این بخش‌ها به‌طور کلی شامل موارد زیر هستند:

```
command [options] [arguments]
```

✅ **`command`** → نام برنامه یا دستوری که اجرا می‌شود.
 ✅ **`[options]`** → (اختیاری) تغییر رفتار دستور با استفاده از فلگ‌ها (سوئیچ‌ها).
 ✅ **`[arguments]`** → (اختیاری) ورودی‌هایی که دستور روی آن‌ها اعمال می‌شود.

#### Command `cat`

کار اصلی آن نمایش کل محتوای فایل در ترمینال است. این دستور pagination و اسکرول ندارد.

### Command **`exit`**

دستور `exit` برای خروج از محیط ترمینال یا بستن پوسته بش (bash shell) استفاده می‌شود.

#### Command  **`free`**

این دستور میزان مصرف حافظه **RAM** و حافظه **Swap** را نمایش می‌دهد. خروجی معمول شامل مقادیر زیر است:

حافظه کل (total)

حافظه استفاده‌شده (used)

حافظه آزاد (free)

حافظه قابل استفاده (available)

#### Command  **`uname`**

با این دستور می‌توانید اطلاعاتی در مورد سیستم‌عامل دریافت کنید. به عنوان مثال:

برای مشاهده کرنل سیستم، از `uname -r` استفاده کنید.

برای دریافت اطلاعات کامل سیستم، از `uname -a` استفاده کنید.

#### Command  **`lscpu`**

اطلاعاتی در مورد پردازنده سیستم، شامل تعداد هسته‌ها، معماری پردازنده، سرعت پردازنده و سایر جزئیات سخت‌افزاری ارائه می‌دهد.

#### Command  **`lspci`**

این دستور جزئیات سخت‌افزاری مرتبط با مادربورد و دستگاه‌های متصل از طریق PCI (مانند کارت گرافیک، شبکه و غیره) را نمایش می‌دهد.

------

مسیرهای محیطی یا **PATH**

متغیر **PATH** دایرکتوری‌هایی را مشخص می‌کند که سیستم در آن‌ها به دنبال دستورات یا برنامه‌های اجرایی می‌گردد.

## مسیرهای متداول:

برای کاربران عادی:

```
/bin, /usr/bin, /usr/local/bin
```

برای مدیر سیستم (Admin):

```
/sbin, /usr/sbin, /usr/local/sbin
```

برای مشاهده مقدار متغیر `PATH` می‌توانید دستور زیر را اجرا کنید:

```
echo $PATH
```

## اهمیت PATH:

هنگامی که یک دستور مانند `ping` وارد می‌کنید، سیستم به صورت خودکار در مسیرهای تعریف‌شده در متغیر PATH جستجو کرده و فایل اجرایی مربوطه را اجرا می‌کند.

#### Command `type`

با این دستور می‌توانید مسیر دقیق فایل اجرایی یک دستور را پیدا کنید. به عنوان مثال:

```
type ping
```

**خروجی:**

```
ping is /usr/bin/ping
```

#### Command  **`echo`**

دستور `echo` برای چاپ متن یا مقدار یک متغیر در ترمینال استفاده می‌شود.
 مثال:

```
echo "Hello, World!"
```

اگر از `$` استفاده کنید، مقدار یک متغیر چاپ می‌شود:

```
a="5"
echo $a
```

## **متغیرهای محیطی (Environment Variables):**

متغیرهای محیطی مقادیر موقتی هستند که در ترمینال تنظیم می‌شوند. می‌توانید آن‌ها را تعریف کرده و مقادیرشان را مشاهده کنید:

```
MY_VAR="Hello"
echo $MY_VAR
```

نکته: متغیرهای تعریف‌شده در محیط ترمینال با بستن ترمینال پاک می‌شوند.

#### Command  **`man`**

دستور `man` (manual) راهنمای کاملی برای دستورات لینوکس ارائه می‌دهد. برای مثال:

```
man uname
```

#### Command  **`pwd`**

این دستور مسیر کامل دایرکتوری فعلی که در آن کار می‌کنید را نمایش می‌دهد.

#### Command  **`history`**

با این دستور می‌توانید لیستی از تمام دستوراتی که در ترمینال وارد کرده‌اید، مشاهده کنید.

با وارد کردن ctrl+r می توانید در هیستوری جستجو را انجام دهید.

## مدیریت اجرای وظایف (Jobs) در لینوکس

در لینوکس، می‌توانید وظایف یا فرآیندهای در حال اجرا را متوقف، حذف، یا مدیریت کنید. این کار از طریق کلید‌های ترکیبی و دستورات خاص انجام می‌شود.

------

## **توقف موقت یک کار (Stop Job)**

اگر در حال اجرای یک فرآیند مانند دستور `ping` هستید و می‌خواهید آن را متوقف کنید، می‌توانید با استفاده از ترکیب کلید **`Ctrl + Z`** این کار را انجام دهید.

**توضیح عملکرد:**
با زدن این ترکیب کلید، فرآیند به‌صورت موقت متوقف شده و به حالت *Suspend* یا معلق می‌رود. این فرآیند هنوز در حافظه وجود دارد و می‌توان آن را از همان نقطه‌ای که متوقف شده است، ادامه داد.

**مثال:**

```
ping google.com
(Ctrl + Z)
```

خروجی:

```
[1]+  Stopped   ping google.com
```

------

## **حذف کامل یک کار (Kill Job)**

#### Command `kill`

برای حذف یک فرآیند، از دستور **`kill`** یا کلید میانبر **`Ctrl + C`** استفاده می‌شود. این کار فرآیند را به طور کامل خاتمه می‌دهد و برخلاف توقف موقت، امکان ادامه دادن آن وجود ندارد.

**کاربرد:**
 اگر در حال اجرای فرآیندی مانند تبدیل یک فایل ویدیویی هستید و آن را حذف (kill) کنید، باید فرآیند را از ابتدا شروع کنید.

**تفاوت با توقف:**

توقف: فرآیند را متوقف می‌کند و می‌توان ادامه داد.

حذف: فرآیند را به‌طور کامل خاتمه می‌دهد.

**مثال:**

```
kill %1
```

خروجی:

```
[1]+  Terminated   ping google.com
```

------

## **اجرای یک فرآیند در پس‌زمینه با `&`**

با افزودن علامت **`&`** به انتهای یک دستور، می‌توانید آن دستور را در **پس‌زمینه** اجرا کنید. این کار باعث می‌شود فرآیند بدون نیاز به انتظار کاربر اجرا شود و ترمینال همچنان برای دستورات دیگر آزاد باشد.

- **کاربرد:**

  - اجرای فرآیندهایی که نیاز به زمان طولانی دارند، بدون اشغال کردن ترمینال.

- **مثال:**

  ```
  ping google.com &
  ```

  خروجی:

  ```
  [1] 12345
  ```

  عدد `[1]` شماره فرآیند (Job ID) و `12345` شماره فرآیند سیستم (PID) است.

------

## **ادامه دادن یک فرآیند متوقف‌شده با `bg`**

اگر یک فرآیند را با **`Ctrl + Z`** متوقف کرده‌اید، می‌توانید با دستور **`bg`** آن را ادامه دهید. این دستور فرآیند را در حالت **پس‌زمینه** (Background) اجرا می‌کند.

**کاربرد:**

زمانی که نمی‌خواهید خروجی فرآیند در ترمینال نمایش داده شود و ترمینال برای دستورات دیگر آزاد بماند.

**مثال:**

```
bg %1
bg ping
```

خروجی:

```
[1]+  ping google.com &
```

------

## **بازگرداندن فرآیند به پیش‌زمینه با `fg`**

اگر یک فرآیند در حالت پس‌زمینه اجرا می‌شود یا متوقف شده است، می‌توانید با دستور **`fg`** آن را به حالت **پیش‌زمینه** (Foreground) بازگردانید.

- **کاربرد:**

  - زمانی که می‌خواهید فرآیند را در حالت تعاملی مدیریت کنید یا خروجی آن را مشاهده کنید.

- **مثال:**

  ```
  fg %1
  fg ping
  ```

  خروجی:

  ```
  ping google.com
  ```

------

## **مدیریت فرآیندها با Job ID و PID**

**Job ID (`%1`, `%2`, ...)**
 شماره‌ای است که برای شناسایی فرآیندهای متوقف‌شده یا در حال اجرا در پس‌زمینه استفاده می‌شود.

**PID (Process ID)**
 یک شماره منحصربه‌فرد است که توسط سیستم برای هر فرآیند اختصاص داده می‌شود.

#### Command `jobs`

 با دستور `jobs` می‌توانید لیستی از فرآیندهای متوقف‌شده یا در پس‌زمینه را مشاهده کنید.

```
jobs
```

------

## خلاصه دستورات مرتبط با مدیریت فرآیندها

| **دستور**  | **عملکرد**                                                |
| ---------- | --------------------------------------------------------- |
| `Ctrl + Z` | متوقف کردن موقت فرآیند و انتقال آن به حالت Suspend.       |
| `Ctrl + C` | خاتمه کامل فرآیند.                                        |
| `&`        | اجرای فرآیند در پس‌زمینه.                                  |
| `bg`       | ادامه دادن فرآیند متوقف‌شده و اجرای آن در پس‌زمینه.         |
| `fg`       | بازگرداندن فرآیند از پس‌زمینه یا حالت Suspend به پیش‌زمینه. |
| `kill`     | حذف کامل فرآیند با استفاده از Job ID یا PID.              |
| `jobs`     | نمایش لیست فرآیندهای متوقف‌شده یا در حال اجرا در پس‌زمینه.  |

------

## محل پیش‌فرض مستندات در لینوکس

در سیستم‌های لینوکس، مستندات و راهنماهای دستورات و برنامه‌ها معمولاً در دایرکتوری‌های خاصی ذخیره می‌شوند. مهم‌ترین مسیرها عبارت‌اند از:

------

## 1. مستندات `man` 

📌 مسیر:

```
/usr/share/man/
```

✅ **توضیح:**

- مستندات `man` به بخش‌های مختلفی تقسیم می‌شوند (`man1`، `man2`، ...).
- این صفحات شامل توضیحات فنی و نحوه استفاده از دستورات و توابع سیستم هستند.

🔹 **مثال:** نمایش مسیر مستندات `ls`

```sh
man -w ls
```

🔹 **ساختار دایرکتوری:**

```
/usr/share/man/man1/   # مستندات مربوط به دستورات کاربر
/usr/share/man/man2/   # مستندات مربوط به فراخوانی‌های سیستمی (System Calls)
/usr/share/man/man3/   # مستندات مربوط به توابع کتابخانه‌ای (Library Functions)
/usr/share/man/man5/   # مستندات مربوط به فرمت فایل‌ها
/usr/share/man/man8/   # مستندات دستورات مدیریتی (Admin Commands)
```

------

## 2. مستندات `info`

📌 مسیر:

```
/usr/share/info/
```

✅ **توضیح:**

- `info` جایگزینی برای `man` است که مستندات تفصیلی‌تری ارائه می‌دهد.
- فرمت این اسناد به‌صورت `.info.gz` یا `.info` است.

🔹 **مثال:** نمایش مسیر مستندات `ls`

```sh
info ls
```

------

## 3. مستندات عمومی (`doc`)

📌 مسیر:

```
/usr/share/doc/
```

✅ **توضیح:**

- شامل مستندات مربوط به پکیج‌ها و برنامه‌های نصب‌شده روی سیستم است.
- معمولاً شامل فایل‌های README، راهنماها، و اسناد مربوط به توسعه‌دهندگان است.

🔹 **مثال:** مشاهده مستندات مربوط به `bash`

```sh
ls /usr/share/doc/bash/
```

------

## 4. مستندات در `/usr/local/share/doc/`

📌 مسیر:

```
/usr/local/share/doc/
```

✅ **توضیح:**

- مشابه `/usr/share/doc/` است اما برای برنامه‌هایی که به‌صورت دستی نصب شده‌اند.
- اگر نرم‌افزاری را از سورس کامپایل کنید، مستندات آن معمولاً در اینجا قرار می‌گیرد.

------

## 5. محل مستندات Kernel و API

📌 مسیر:

```
/usr/share/doc/linux-doc/
```

✅ **توضیح:**

- شامل مستندات مرتبط با کرنل لینوکس و APIهای آن است.
- برخی از فایل‌های مهم مانند `kernel-api.txt` و `sysctl.txt` در اینجا ذخیره می‌شوند.

🔹 **نصب مستندات کرنل در اوبونتو:**

```sh
sudo apt install linux-doc
```

------

## جمع‌بندی

| مسیر                        | توضیح                                |
| --------------------------- | ------------------------------------ |
| `/usr/share/man/`           | مستندات `man` (صفحات راهنما)         |
| `/usr/share/info/`          | مستندات `info` (راهنماهای پیشرفته)   |
| `/usr/share/doc/`           | مستندات عمومی پکیج‌های نصب‌شده         |
| `/usr/local/share/doc/`     | مستندات برنامه‌های نصب‌شده به‌صورت دستی |
| `/usr/share/doc/linux-doc/` | مستندات کرنل لینوکس و API            |

### Command  `less`

**کاربرد:** نمایش محتوای فایل‌ها به‌صورت صفحه‌به‌صفحه

✅ **توضیح:**
 دستور `less` برای مشاهده محتوای یک فایل بدون باز کردن آن در ویرایشگرهای متنی مانند `vim` یا `nano` استفاده می‌شود. برخلاف `cat` که کل محتوا را یک‌جا نمایش می‌دهد، این دستور اجازه اسکرول به بالا و پایین را می‌دهد.

✅ **نحوه استفاده:**

```sh
less filename
```

🔹 فشردن کلید `q` باعث خروج از محیط `less` می‌شود.
 🔹 کلیدهای `↑` و `↓` برای پیمایش، و `space` برای رفتن به صفحه بعد استفاده می‌شود.
 🔹 می‌توان با `/keyword` در متن جستجو کرد.

------

### Command   `whatis`

**کاربرد:** نمایش توضیح کوتاه درباره یک دستور

✅ **توضیح:**
 این دستور خلاصه‌ای از توضیح مربوط به یک دستور را نمایش می‌دهد. اطلاعات نمایش‌داده‌شده از پایگاه داده `man` استخراج می‌شود.

✅ **نحوه استفاده:**

```sh
whatis ls
```

🔹 خروجی معمولاً شامل یک خط توضیح کوتاه درباره دستور است.
 🔹 مثال خروجی برای `ls`:

```
ls (1) - list directory contents
```

------

### Command  `apropos`

**کاربرد:** جستجو در مستندات `man` بر اساس کلمات کلیدی

✅ **توضیح:**
 اگر نام دقیق یک دستور را نمی‌دانید اما توضیحی کلی در مورد آن دارید، `apropos` می‌تواند به شما کمک کند.

✅ **نحوه استفاده:**

```sh
apropos search-term
```

🔹 مثال: جستجوی همه دستورات مرتبط با "list"

```sh
apropos list
```

🔹 خروجی ممکن است شامل چندین خط باشد که نام دستورات مرتبط و توضیح مختصرشان را نمایش می‌دهد.

------

### Command  `info`

**کاربرد:** نمایش مستندات جامع‌تر درباره دستورات

✅ **توضیح:**
 برخی از ابزارهای لینوکسی علاوه بر `man` دارای مستندات `info` هستند که توضیحات کامل‌تر و سازمان‌یافته‌تری دارند.

✅ **نحوه استفاده:**

```sh
info ls
```

🔹 در محیط `info`، کلیدهای پیمایش مانند `less` عمل می‌کنند.
 🔹 خروج با کلید `q`.

------

### Command  `whereis`

**کاربرد:** یافتن مکان نصب یک دستور یا برنامه

✅ **توضیح:**
 این دستور مسیر باینری (اجرایی)، صفحات `man` و فایل‌های سورس یک برنامه را نمایش می‌دهد.

✅ **نحوه استفاده:**

```sh
whereis ls
```

🔹 مثال خروجی:

```
ls: /bin/ls /usr/share/man/man1/ls.1.gz
```

🔹 این خروجی نشان می‌دهد که `ls` در `/bin/ls` قرار دارد و مستندات آن در `/usr/share/man/man1/ls.1.gz` موجود است.

------

### Command  `locate`

**کاربرد:** جستجوی سریع فایل‌ها بر اساس نام

✅ **توضیح:**
 برخلاف `find` که به‌صورت مستقیم در سیستم فایل جستجو می‌کند، `locate` از یک پایگاه داده از پیش ایندکس‌شده استفاده می‌کند، بنابراین سریع‌تر است. البته این پکیج باید نصب شود.

✅ **نحوه استفاده:**

```sh
locate filename
```

🔹 مثال: جستجوی همه فایل‌هایی که شامل `bashrc` هستند:

```sh
locate bashrc
```

🔹 اگر `locate` هیچ نتیجه‌ای برنگرداند، ممکن است نیاز به به‌روزرسانی پایگاه داده با دستور زیر باشد:

```sh
sudo updatedb
```

------

### **جمع‌بندی**

| دستور     | کاربرد                                  |
| --------- | --------------------------------------- |
| `less`    | نمایش صفحه‌به‌صفحه محتوای فایل‌ها          |
| `whatis`  | نمایش توضیح کوتاه درباره یک دستور       |
| `apropos` | جستجو در مستندات `man` بر اساس کلیدواژه |
| `info`    | نمایش راهنمای کامل‌تر از `man`           |
| `whereis` | نمایش مسیر باینری و مستندات یک دستور    |
| `locate`  | جستجوی سریع فایل‌ها بر اساس نام          |

هرکدام از این دستورات در مدیریت سیستم و دسترسی به اطلاعات بسیار مفید هستند. 🚀

## **📌 توضیح کامل FHS (Filesystem Hierarchy Standard) در لینوکس**

## FHS چیست؟

**FHS (Filesystem Hierarchy Standard)** یک استاندارد برای تعیین ساختار و سازمان‌دهی دایرکتوری‌ها در سیستم‌های مبتنی بر لینوکس و یونیکس است. این استاندارد مشخص می‌کند که فایل‌ها و دایرکتوری‌های مختلف در سیستم در کجا قرار بگیرند تا یکپارچگی، مدیریت‌پذیری و سازگاری بین توزیع‌های مختلف لینوکس حفظ شود.

------

## **📂 معرفی دایرکتوری‌های اصلی در FHS**

## 1. `/` (Root) – ریشه فایل‌سیستم

📌 **توضیح:**
 دایرکتوری ریشه، بالاترین سطح در سلسله‌مراتب فایل‌سیستم لینوکس است و همه چیز (فایل‌ها، دایرکتوری‌ها، دستگاه‌ها و ...) زیرمجموعه آن قرار دارند.

🔹 **ویژگی‌ها:**

- همه دایرکتوری‌های دیگر از `/` منشعب می‌شوند.
- به هیچ عنوان نباید این دایرکتوری پر یا خراب شود؛ زیرا سیستم عامل ممکن است دچار مشکل شود.

------

## 2. `/bin/` – فایل‌های اجرایی اصلی

📌 **توضیح:**
 شامل دستورات و ابزارهای اساسی سیستم است که برای همه کاربران در دسترس هستند، حتی در حالت بازیابی (recovery mode).

🔹 **دستورات مهم:**

- `ls` (لیست فایل‌ها)
- `cp` (کپی فایل‌ها)
- `mv` (انتقال فایل‌ها)
- `rm` (حذف فایل‌ها)
- `cat` (نمایش محتوا)

------

## 3. `/sbin/` – فایل‌های اجرایی مخصوص مدیر سیستم (Root)

📌 **توضیح:**
 شامل ابزارهای سیستمی و مدیریتی که فقط توسط کاربر **ریشه (root)** قابل استفاده هستند.

🔹 **دستورات مهم:**

- `fdisk` (مدیریت پارتیشن‌ها)
- `fsck` (بررسی و تعمیر فایل‌سیستم)
- `reboot` (راه‌اندازی مجدد سیستم)
- `shutdown` (خاموش کردن سیستم)

------

## 4. `/usr/` – برنامه‌های کاربری و کتابخانه‌ها

📌 **توضیح:**
 حاوی برنامه‌ها، کتابخانه‌ها، مستندات و داده‌های مربوط به نرم‌افزارهایی است که برای کاربران عادی نصب شده‌اند.

🔹 **زیرشاخه‌های مهم:**

- `/usr/bin/` → ابزارهای اجرایی برای کاربران عادی
- `/usr/sbin/` → ابزارهای اجرایی مدیریتی برای root
- `/usr/lib/` → کتابخانه‌های مرتبط با برنامه‌ها
- `/usr/share/` → داده‌های عمومی مانند مستندات، آیکون‌ها، قالب‌ها

------

## 5. `/var/` – فایل‌های متغیر و پویا

📌 **توضیح:**
 این دایرکتوری شامل فایل‌هایی است که مرتباً تغییر می‌کنند، مانند لاگ‌ها، کش، داده‌های موقت و صف‌های پردازشی.

🔹 **زیرشاخه‌های مهم:**

- `/var/log/` → فایل‌های لاگ (مثلاً `/var/log/syslog` برای ثبت رخدادهای سیستم)
- `/var/spool/` → صف‌های چاپگر و ایمیل
- `/var/tmp/` → فایل‌های موقتی که بعد از ریبوت باقی می‌مانند

------

## 6. `/etc/` – فایل‌های پیکربندی سیستم

📌 **توضیح:**
 تمام فایل‌های پیکربندی مهم سیستم و برنامه‌ها در این دایرکتوری ذخیره می‌شوند.

🔹 **فایل‌های مهم:**

- `/etc/passwd` → اطلاعات کاربران سیستم
- `/etc/shadow` → پسوردهای کاربران (رمزگذاری‌شده)
- `/etc/fstab` → اطلاعات مربوط به پارتیشن‌های سیستم
- `/etc/hosts` → تعریف آدرس‌های IP و نام‌های میزبان

------

## 7. `/home/` – دایرکتوری کاربران عادی

📌 **توضیح:**
 هر کاربر در سیستم یک دایرکتوری مخصوص به خود دارد که در `/home/username/` قرار می‌گیرد.

🔹 **مثال:**

- `/home/ali/` → اطلاعات و تنظیمات شخصی کاربر `ali`
- `/home/reza/` → اطلاعات و تنظیمات شخصی کاربر `reza`

------

## 8. `/root/` – دایرکتوری مخصوص کاربر Root

📌 **توضیح:**
 برخلاف `/home/` که مخصوص کاربران عادی است، کاربر **مدیر (root)** دارای یک دایرکتوری شخصی در `/root/` است.

------

## 9. `/boot/` – فایل‌های بوت سیستم

📌 **توضیح:**
 این دایرکتوری شامل فایل‌های ضروری برای راه‌اندازی سیستم است، مانند کرنل لینوکس و گراب (GRUB).

🔹 **فایل‌های مهم:**

- `/boot/vmlinuz` → کرنل لینوکس
- `/boot/initrd.img` → فایل‌های ضروری هنگام بوت شدن
- `/boot/grub/` → تنظیمات بوت‌لودر GRUB

------

## 10. `/tmp/` – فایل‌های موقتی

📌 **توضیح:**
 برنامه‌ها از این دایرکتوری برای ذخیره فایل‌های موقتی استفاده می‌کنند. فایل‌های موجود در `/tmp/` معمولاً بعد از ری‌استارت سیستم حذف می‌شوند.

------

## 11. `/dev/` – دستگاه‌های سخت‌افزاری به عنوان فایل

📌 **توضیح:**
 تمام دستگاه‌های سخت‌افزاری و مجازی به‌عنوان فایل در این دایرکتوری نمایش داده می‌شوند.

🔹 **مثال‌های مهم:**

- `/dev/sda` → اولین هارد دیسک
- `/dev/sdb1` → اولین پارتیشن از دومین هارد
- `/dev/null` → فایل ویژه‌ای که هر چیزی در آن بنویسید، حذف می‌شود

------

## 12. `/proc/` – اطلاعات زنده سیستم و پردازش‌ها

📌 **توضیح:**
 یک دایرکتوری مجازی که شامل اطلاعات مربوط به پردازش‌های در حال اجرا و کرنل سیستم است.

🔹 **مثال‌های مهم:**

- `/proc/cpuinfo` → اطلاعات پردازنده
- `/proc/meminfo` → اطلاعات حافظه سیستم
- `/proc/uptime` → زمان روشن بودن سیستم

------

## 13. `/sys/` – اطلاعات سخت‌افزاری سیستم

📌 **توضیح:**
 مشابه `/proc/` است اما بیشتر برای نمایش و تنظیم سخت‌افزار استفاده می‌شود.

------

## 14. `/media/` – محل اتصال (Mount) دستگاه‌های جانبی

📌 **توضیح:**
 زمانی که یک دیسک USB یا CD/DVD را به سیستم متصل می‌کنید، لینوکس معمولاً آن را در `/media/` قرار می‌دهد.

🔹 **مثال:**

- `/media/usb-drive/` → یک فلش مموری متصل شده
- `/media/cdrom/` → یک دیسک CD/DVD

------

## 15. `/mnt/` – محل اتصال موقت سیستم فایل‌ها

📌 **توضیح:**
 برای اتصال (mount) دستی پارتیشن‌ها و دیسک‌ها استفاده می‌شود. 

🔹 **مثال:**

```sh
mount /dev/sdb1 /mnt
```

------

## **🎯 نتیجه‌گیری**

**FHS** ساختاری استاندارد برای دایرکتوری‌های لینوکس ارائه می‌دهد که باعث می‌شود سیستم‌عامل بهینه، پایدار و قابل مدیریت باشد.

📌 **دایرکتوری‌های کلیدی:**
 ✅ **`/bin` و `/sbin`** → دستورات اصلی سیستم
 ✅ **`/etc`** → تنظیمات و پیکربندی
 ✅ **`/var` و `/tmp`** → داده‌های متغیر و موقتی
 ✅ **`/home` و `/root`** → اطلاعات کاربران
 ✅ **`/dev` و `/proc`** → دستگاه‌های سخت‌افزاری و اطلاعات پردازش‌ها

این استاندارد به مدیران سیستم و توسعه‌دهندگان کمک می‌کند تا به‌راحتی سیستم را مدیریت کنند. 🚀

## دایرکتوری های مهم در لینوکس که تغییرات در آن ها ممکن است سیستم عامل را دچار اختلال کند.

## **📌 دایرکتوری‌های مهم در لینوکس و کاربرد آن‌ها**

در لینوکس، دایرکتوری **`/etc/`** و زیرشاخه‌های آن شامل **فایل‌های پیکربندی** هستند که برای تنظیمات سیستم، کاربران، سرویس‌ها و برنامه‌های مختلف مورد استفاده قرار می‌گیرند. در اینجا به بررسی مهم‌ترین آن‌ها می‌پردازیم:

------

## **1️⃣ `/etc/` – دایرکتوری تنظیمات سیستم (System Configuration Directory)**

📌 **ویژگی‌ها:**

- شامل **فایل‌های پیکربندی سیستم و برنامه‌ها** است.
- معمولاً شامل **فایل‌های متنی (Plain Text)** است که تنظیمات را ذخیره می‌کنند.
- در لینوکس، **تمام تغییرات مربوط به سرویس‌ها، کاربران، مجوزها و شبکه در این دایرکتوری انجام می‌شود**.
- **برخی از مهم‌ترین فایل‌ها و دایرکتوری‌های داخل `/etc/`**:

| مسیر                      | توضیح                                     |
| ------------------------- | ----------------------------------------- |
| `/etc/fstab`              | اطلاعات مربوط به **مونت شدن فایل‌سیستم‌ها** |
| `/etc/passwd`             | لیست **کاربران سیستم** و اطلاعات آن‌ها     |
| `/etc/shadow`             | پسوردهای رمزگذاری‌شده کاربران              |
| `/etc/group`              | گروه‌های کاربران                           |
| `/etc/sudoers`            | تنظیمات مربوط به **دسترسی sudo**          |
| `/etc/hosts`              | نگاشت **IP** به نام‌های دامنه محلی         |
| `/etc/hostname`           | نام میزبان سیستم                          |
| `/etc/network/interfaces` | تنظیمات شبکه (در برخی توزیع‌ها)            |
| `/etc/resolv.conf`        | تنظیمات **DNS**                           |
| `/etc/cron.d/`            | تنظیمات وظایف زمان‌بندی‌شده **(Cron Jobs)** |

------

## **2️⃣ `/etc/fstab` – تنظیمات فایل‌سیستم و پارتیشن‌ها**

📌 **ویژگی‌ها:**

- شامل اطلاعات **پارتیشن‌های سیستم و نحوه مونت شدن آن‌ها** در هنگام بوت شدن.
- هنگام روشن شدن سیستم، کرنل این فایل را می‌خواند و مشخص می‌کند که کدام پارتیشن‌ها به کجا **Mount** شوند.

🔹 **مثال یک فایل `/etc/fstab/`:**

```plaintext
UUID=12345678-90ab-cdef-1234-567890abcdef / ext4 defaults 0 1
/dev/sda1 /boot ext4 defaults 0 2
/dev/sdb1 /mnt/data ntfs defaults 0 0
```

🔹 **ساختار یک خط در `fstab`**:

| ستون                |                            توضیح |
| ------------------- | -------------------------------: |
| 1️⃣ **نام دستگاه**    |     نام دیوایس یا `UUID` پارتیشن |
| 2️⃣ **نقطه مونت**     |   محل اتصال پارتیشن به فایل‌سیستم |
| 3️⃣ **نوع فایل‌سیستم** |      `ext4`، `ntfs`، `xfs` و ... |
| 4️⃣ **گزینه‌های مونت** | `defaults`، `noexec`، `ro` و ... |
| 5️⃣ **dump**          | برای پشتیبان‌گیری (`0` = غیرفعال) |
| 6️⃣ **fsck order**    |            ترتیب بررسی هنگام بوت |

✅ **مثال کاربردی:**
 برای **مونت خودکار یک پارتیشن USB در `/mnt/usb`** هنگام بوت:

```plaintext
/dev/sdb1 /mnt/usb vfat defaults 0 0
```

------

## **3️⃣ `/etc/passwd` – اطلاعات کاربران سیستم**

📌 **ویژگی‌ها:**

- شامل **لیست تمام کاربران سیستم و اطلاعات مرتبط با آن‌ها**.
- هر کاربر یک خط مجزا دارد.
- رمزهای عبور **قبلاً در همین فایل ذخیره می‌شدند** اما امروزه در **`/etc/shadow/`** قرار دارند.

🔹 **مثال یک فایل `/etc/passwd/`:**

```plaintext
root:x:0:0:root:/root:/bin/bash
user1:x:1001:1001:User One:/home/user1:/bin/bash
```

🔹 **ساختار هر خط در `/etc/passwd`**:

| فیلد                                                | توضیح                                           |
| --------------------------------------------------- | ----------------------------------------------- |
| 1️⃣ **نام کاربری**                                    | `root`، `user1` و ...                           |
| 2️⃣ **پسورد (x به معنی ذخیره شدن در `/etc/shadow/`)** | `x`                                             |
| 3️⃣ **UID (شناسه کاربر)**                             | `0` برای `root`، ۱۰۰۰+ برای کاربران عادی        |
| 4️⃣ **GID (شناسه گروه)**                              | `0` برای `root`، ۱۰۰۰+ برای گروه‌های عادی        |
| 5️⃣ **توضیحات اضافی**                                 | `root`، `User One` و ...                        |
| 6️⃣ **دایرکتوری خانه (Home Directory)**               | `/root` برای `root`، `/home/user1` برای `user1` |
| 7️⃣ **شل پیش‌فرض (Shell)**                             | `/bin/bash` یا `/bin/nologin`                   |

✅ **مثال کاربردی:**
 برای ایجاد یک کاربر جدید و تعیین رمز عبور:

```sh
sudo useradd newuser
sudo passwd newuser
```

## تفاوت بین `/bin/`، `/usr/bin/` و `/usr/local/bin/` در لینوکس

در لینوکس، این سه دایرکتوری حاوی **فایل‌های اجرایی (Executable)** هستند، اما کاربرد و محل قرارگیری آن‌ها متفاوت است. در اینجا به تفاوت‌های کلیدی آن‌ها می‌پردازیم:

------

## **1️⃣ `/bin/` – ابزارهای اجرایی پایه‌ای (Essential Binaries)**

📌 **توضیح:**

- شامل دستورات و ابزارهای **اساسی** موردنیاز برای بوت شدن سیستم و حالت **بازیابی (recovery mode)** است.
- حتی زمانی که سیستم در **حالت تک‌کاربره (single-user mode)** است یا `/usr` در دسترس نیست، باید قابل اجرا باشد.
- این دایرکتوری همیشه در دسترس است، زیرا در پارتیشن **`/` (root)** قرار دارد.

🔹 **دستورات مهم در `/bin/`**

| دستور   | کاربرد                         |
| ------- | ------------------------------ |
| `ls`    | لیست کردن فایل‌ها و دایرکتوری‌ها |
| `cp`    | کپی کردن فایل‌ها                |
| `mv`    | انتقال یا تغییر نام فایل‌ها     |
| `rm`    | حذف فایل‌ها                     |
| `mkdir` | ایجاد دایرکتوری                |
| `rmdir` | حذف دایرکتوری                  |
| `cat`   | نمایش محتوای فایل‌ها            |
| `echo`  | چاپ متن در خروجی               |
| `bash`  | اجرای شل (Bash)                |
| `chmod` | تغییر مجوزهای فایل             |
| `chown` | تغییر مالکیت فایل‌ها            |

✅ **ویژگی مهم:** در زمانی که `/usr` جداگانه **Mount** نشده است، دستورات ضروری از `/bin/` قابل اجرا هستند.

------

## **2️⃣ `/usr/bin/` – ابزارهای اجرایی اضافی برای کاربران**

📌 **توضیح:**

- شامل اکثر **برنامه‌ها و ابزارهای کاربردی** برای کاربران عادی است که برای عملکرد پایه‌ای سیستم **ضروری نیستند**.
- برنامه‌های کاربردی که بعداً نصب می‌شوند، معمولاً در **`/usr/bin`** قرار می‌گیرند.
- این دایرکتوری **ممکن است در یک پارتیشن جداگانه باشد** و فقط بعد از بوت شدن سیستم مونت شود.

🔹 **دستورات مهم در `/usr/bin/`**

| دستور    | کاربرد                       |
| -------- | ---------------------------- |
| `vim`    | ویرایشگر متن                 |
| `nano`   | ویرایشگر متن ساده            |
| `wget`   | دانلود فایل‌ها از اینترنت     |
| `curl`   | ارسال درخواست‌های HTTP        |
| `git`    | سیستم کنترل نسخه گیت         |
| `htop`   | نمایش پردازش‌های سیستم        |
| `python` | اجرای اسکریپت‌های پایتون      |
| `perl`   | مفسر زبان Perl               |
| `gcc`    | کامپایلر زبان C              |
| `tar`    | فشرده‌سازی و باز کردن آرشیوها |
| `zip`    | فشرده‌سازی فایل‌ها             |

✅ **ویژگی مهم:** این دایرکتوری شامل برنامه‌های کاربردی است که برای عملکرد اولیه سیستم ضروری نیستند، اما توسط کاربران عادی مورد استفاده قرار می‌گیرند.

------

## **3️⃣ `/usr/local/bin/` – برنامه‌های محلی نصب‌شده توسط کاربر (Locally Installed Binaries)**

📌 **ویژگی‌ها:**

- مخصوص **نرم‌افزارهایی است که به‌صورت دستی نصب شده‌اند** و در مخازن رسمی سیستم وجود ندارند.
- این دایرکتوری در `/usr/local/` قرار دارد و معمولاً برای **برنامه‌هایی که مستقیماً از سورس کامپایل شده‌اند** یا **به‌صورت دستی دانلود شده‌اند**، استفاده می‌شود.
- نرم‌افزارهایی که از طریق **Package Manager (مانند apt یا yum)** نصب می‌شوند، در این دایرکتوری قرار نمی‌گیرند.

✅ **مثال‌های مهم:**

- برنامه‌هایی که **از سورس کامپایل شده‌اند**، مانند:

  ```sh
  ./configure && make && sudo make install
  ```

  🔹 معمولاً فایل اجرایی آن‌ها در `/usr/local/bin/` ذخیره می‌شود.

- اسکریپت‌های سفارشی که توسط کاربر ساخته شده‌اند.

------

## **🆚 مقایسه نهایی: تفاوت‌های کلیدی**

| ویژگی              | `/bin/`                           | `/usr/bin/`                          | `/usr/local/bin/`                         |
| ------------------ | --------------------------------- | ------------------------------------ | ----------------------------------------- |
| **هدف**            | شامل دستورات ضروری برای بوت سیستم | شامل برنامه‌های عمومی کاربران عادی    | شامل برنامه‌های نصب‌شده به‌صورت دستی         |
| **نیاز به `/usr`** | نیازی ندارد                       | نیاز دارد                            | نیاز دارد                                 |
| **مدیریت توسط**    | سیستم‌عامل (مخازن رسمی)            | مدیر سیستم (از طریق Package Manager) | کاربران (نصب دستی یا کامپایل)             |
| **مثال‌ها**         | `ls`، `cp`، `mv`، `rm`، `bash`    | `vim`، `nano`، `wget`، `git`         | برنامه‌های کامپایل‌شده یا اسکریپت‌های سفارشی |

------

## **🎯 چه زمانی از `/usr/local/bin/` استفاده کنیم؟**

✅ **اگر یک برنامه را از سورس کامپایل کرده‌اید** (مثلاً یک نسخه جدید از `vim` یا `htop`)، بهتر است آن را در `/usr/local/bin/` نصب کنید تا با نسخه‌های رسمی سیستم تداخل نداشته باشد.

✅ **اگر یک اسکریپت سفارشی دارید** که می‌خواهید در دسترس همه کاربران قرار گیرد، می‌توانید آن را در `/usr/local/bin/` قرار دهید.

------

## **🚀 نتیجه‌گیری نهایی**

- **`/bin/`** → برای **دستورات پایه‌ای سیستم** که همیشه باید در دسترس باشند.
- **`/usr/bin/`** → برای **برنامه‌های نصب‌شده از مخازن رسمی** که برای کاربران عادی قابل استفاده هستند.
- **`/usr/local/bin/`** → برای **برنامه‌های نصب‌شده دستی یا اسکریپت‌های سفارشی** که خارج از مدیریت رسمی بسته‌ها قرار دارند.

📌 **اگر برنامه‌ای را از طریق پکیج منیجر نصب می‌کنید، به `/usr/bin/` می‌رود. اما اگر برنامه‌ای را مستقیماً از سورس نصب کنید، معمولاً در `/usr/local/bin/` قرار می‌گیرد.** 🚀

------



## 📌 خلاصه تفاوت نصب برنامه‌ها در لینوکس و ویندوز

🔹 **در ویندوز**، برنامه‌ها در یک پوشه مستقل (`C:\Program Files\MyApp\`) نصب می‌شوند و اغلب دارای نسخه‌های خاص خود از فایل‌های DLL هستند. این روش باعث **افزایش حجم، مشکل "DLL Hell" و وابستگی به رجیستری** می‌شود.

🔹 **در لینوکس**، برنامه‌ها در چندین دایرکتوری توزیع می‌شوند:
 📍 **`/usr/bin/`** (فایل اجرایی)
 📍 **`/usr/lib/`** (کتابخانه‌ها)
 📍 **`/etc/`** (تنظیمات)
 📍 **`/var/log/`** (لاگ‌ها)

✅ **مزایای لینوکس**:
 ✔ کاهش حجم به دلیل استفاده از **کتابخانه‌های مشترک**
 ✔ حذف تمیز برنامه‌ها بدون باقی‌ماندن فایل‌های اضافی
 ✔ **عدم وابستگی به رجیستری** و سادگی مدیریت

### Command `touch`

دستور `touch` در سیستم‌عامل‌های مبتنی بر یونیکس مانند لینوکس برای ایجاد فایل‌های جدید و به‌روزرسانی زمان تغییر (Timestamp) فایل‌های موجود استفاده می‌شود.

**ایجاد فایل جدید با دستور touch**

اگر فایلی با نام مشخص‌شده از قبل وجود نداشته باشد، دستور `touch` آن را ایجاد می‌کند.

**به‌روزرسانی زمان فایل موجود**

در صورتی که فایل از قبل وجود داشته باشد، اجرای دستور `touch` باعث به‌روزرسانی زمان آخرین تغییر (Modification Time) آن می‌شود، بدون اینکه تغییری در محتوای فایل ایجاد شود.

**تنظیم تاریخ و زمان دلخواه برای فایل**

یکی از قابلیت‌های پیشرفته دستور `touch` امکان تنظیم یک تاریخ و زمان خاص برای فایل است. برای مثال، اگر بخواهید فایلی ایجاد شود اما زمان ایجاد آن پنج ماه پیش تنظیم گردد، می‌توانید از سوییچ `-t` به همراه تاریخ موردنظر استفاده کنید. ساختار این دستور به شکل زیر خواهد بود:

```bash
touch -t YYYYMMDDHHMM filename
```

**مثال:** اگر بخواهید فایلی ایجاد شود و تاریخ آن ۵ ماه قبل تنظیم شود، می‌توانید تاریخ مورد نظر را مشخص کنید:

```bash
touch -t 202308010800 myfile.txt
```

این دستور یک فایل با نام `myfile.txt` ایجاد کرده یا در صورت وجود، زمان تغییر آن را به **اول آگوست ۲۰۲۳، ساعت ۸:۰۰ صبح** تنظیم می‌کند.

**نکات مهم در نام‌گذاری فایل‌ها**

**حساسیت به حروف بزرگ و کوچک:**
 در لینوکس، نام فایل‌ها به حروف کوچک و بزرگ حساس است؛ یعنی `File.txt` و `file.txt` دو فایل کاملاً متفاوت هستند. اما در ویندوز، این حساسیت وجود ندارد و هر دو نام به یک فایل اشاره خواهند کرد.

**بهترین روش برای جلوگیری از مشکلات احتمالی:**
 به دلیل تفاوت در مدیریت نام فایل‌ها بین سیستم‌عامل‌های مختلف، توصیه می‌شود همیشه نام فایل‌ها را با **حروف کوچک** بنویسید تا از مشکلات احتمالی جلوگیری شود.

#### Command `mkdir`

با این دستور یک فولدر ایجاد می شود.

```
mkdir a
```

اگر دایرکتوری a در دستور زیر وجود نداشته باشد به خطا می خورد و اگر وجود داشت دایرکتوری b ایجاد می شود.

```
mkdir a/b
```

با این option اگر دایرکتوری a وجود نداشت به خطا نمی خورد و ایجاد می کند.

```
mkdir -p a/b
```

### Command `cp`

دستور `cp` در لینوکس برای **کپی کردن فایل‌ها و دایرکتوری‌ها** استفاده می‌شود. این دستور می‌تواند فایل‌ها را در همان مسیر یا مسیرهای دیگر کپی کند و دارای گزینه‌های مختلفی برای کنترل نحوه کپی است. در ادامه، تمام دستورات ذکرشده را بررسی می‌کنیم:

```bash
cp a b
```

این دستور فایل **`a`** را به **`b`** کپی می‌کند.

اگر فایل **`b`** از قبل وجود داشته باشد، بدون هیچ هشداری، با محتوای فایل **`a`** جایگزین می‌شود.

اگر فایل **`b`** وجود نداشته باشد، یک فایل جدید با همان محتوا ایجاد می‌شود.

```bash
cp a folder/b
```

این دستور فایل **`a`** را به دایرکتوری **`folder`** کپی کرده و نام آن را **`b`** قرار می‌دهد.

اگر دایرکتوری **`folder`** از قبل وجود داشته باشد، فایل **`b`** داخل آن ساخته می‌شود.

اگر دایرکتوری **`folder`** وجود نداشته باشد، دستور با خطا مواجه خواهد شد.

```bash
cp a ~/Desktop/b
```

در این دستور:

**`~`** به معنی **دایرکتوری خانگی (Home Directory)** کاربر است.

این دستور فایل **`a`** را به **دسکتاپ (Desktop)** کپی کرده و نام آن را **`b`** می‌گذارد.

اگر فایل **`b`** در مسیر **`~/Desktop/`** وجود داشته باشد، جایگزین خواهد شد.

```bash
cp -R video/ ~/Desktop/
```

در این دستور:

**`-R` یا `--recursive`** به معنی **کپی کردن بازگشتی (Recursive)** است، یعنی کل دایرکتوری **`video/`** همراه با همه فایل‌ها و زیردایرکتوری‌های آن کپی می‌شود.

دایرکتوری **`video/`** به همراه تمام محتوای آن در دسکتاپ ذخیره خواهد شد.

اگر **`~/Desktop/video/`** از قبل وجود داشته باشد، محتوای **`video/`** در آن ادغام می‌شود.

```bash
cp -f a b
```

در این دستور:

**`-f` یا `--force`** به معنی **اجبار در جایگزینی فایل** است.

اگر فایل **`b`** از قبل وجود داشته باشد، حتی اگر دارای سطح دسترسی **Read-Only (فقط خواندنی)** باشد، بدون اخطار حذف و با فایل **`a`** جایگزین می‌شود.

این گزینه زمانی مفید است که سیستم به دلیل سطوح دسترسی مانع از جایگزینی فایل شود.

```bash
cp -i a b
```

در این دستور:

**`-i` یا `--interactive`** باعث **درخواست تأیید از کاربر** قبل از جایگزین کردن فایل می‌شود.

اگر فایل 

`b`

 از قبل وجود داشته باشد، سیستم از کاربر سؤال می‌کند:

```
cp: overwrite 'b'? (y/n)
```

اگر کاربر `y` را وارد کند، فایل جایگزین می‌شود.

اگر `n` را وارد کند، عملیات لغو می‌شود.

```bash
cp -u a b
```

در این دستور:

**`-u` یا `--update`** باعث می‌شود **فقط در صورتی که `a` جدیدتر از `b` باشد، فایل کپی شود**.

اگر فایل **`b`** از قبل وجود داشته باشد و محتوای آن جدیدتر از **`a`** باشد، هیچ تغییری ایجاد نمی‌شود.

این گزینه برای **پشتیبان‌گیری (Backup) و همگام‌سازی فایل‌ها** بسیار مفید است.

```bash
cp -p a b
```

در این دستور:

`-p` یا `--preserve`

 باعث می‌شود که هنگام کپی کردن فایل، ویژگی‌های زیر حفظ شوند:

**زمان آخرین تغییر (Modification Time)**

**مالکیت (Owner and Group)**

**مجوزهای دسترسی (Permissions)**

در حالت عادی، وقتی یک فایل را کپی می‌کنید، زمان ایجاد آن جدید می‌شود، اما این گزینه مانع از این تغییر می‌شود.

### Command `rm`

دستور `rm` در لینوکس برای **حذف فایل‌ها و دایرکتوری‌ها** استفاده می‌شود. این دستور فایل‌ها را به سطل زباله (Trash) نمی‌فرستد، بلکه به‌طور **دائمی و بدون امکان بازیابی مستقیم** آن‌ها را حذف می‌کند. در ادامه، دستورات موردنظر را بررسی می‌کنیم.

```bash
rm a
```

این دستور فایل **`a`** را حذف می‌کند.

اگر فایل **`a`** وجود داشته باشد، بدون هیچ پیغامی حذف خواهد شد.

اگر فایل `a` وجود نداشته باشد، با خطای زیر مواجه خواهید شد:

```
rm: cannot remove 'a': No such file or directory
```

این دستور فقط برای حذف **فایل‌ها** استفاده می‌شود و نمی‌تواند دایرکتوری‌ها را حذف کند.

**اگر فایل دارای سطح دسترسی "فقط خواندنی (Read-Only)" باشد، قبل از حذف تأیید می‌خواهد:**

```
rm: remove write-protected regular file 'a'? (y/n)
```

- اگر `y` را بزنید، فایل حذف می‌شود.
- اگر `n` را بزنید، حذف لغو می‌شود.

```bash
rm -rf a/
```

در این دستور:

- **`-r` یا `--recursive`**: دایرکتوری را به‌صورت بازگشتی (Recursive) حذف می‌کند. یعنی اگر `a/` شامل فایل‌ها و زیردایرکتوری‌هایی باشد، همه‌ی آن‌ها حذف خواهند شد.
- **`-f` یا `--force`**: بدون نمایش پیام تأیید، حذف را انجام می‌دهد. حتی اگر فایل‌ها **فقط خواندنی** باشند، بدون هشدار حذف می‌شوند.

**مثال:**
 فرض کنید دایرکتوری **`a/`** شامل فایل‌های زیر باشد:

```
a/
 ├── file1.txt
 ├── file2.txt
 ├── subdir/
 │   ├── file3.txt
 │   └── file4.txt
```

با اجرای `rm -rf a/`، کل پوشه **`a/`** و تمام محتویات آن بدون هشدار حذف خواهند شد.

**اگر `-f` را استفاده نکنید (`rm -r a/`)، لینوکس ممکن است برای فایل‌های خاص تأیید بخواهد.**

```bash
rm -rf *
```

این دستور **همه‌ی فایل‌ها و پوشه‌های موجود در مسیر جاری** را به‌طور **دائمی و بدون هشدار** حذف می‌کند.

**اجرا در `/home/user/`:**
 اگر این دستور را در پوشه‌ی خانگی خود اجرا کنید (`/home/user/`)، تمام فایل‌های شخصی شما حذف خواهند شد.

**اجرا در `/`:**
 اگر این دستور را با دسترسی `root` در `/` (ریشه سیستم) اجرا کنید، کل سیستم‌عامل شما حذف می‌شود!
 (البته در سیستم‌های مدرن، این کار با خطا مواجه می‌شود تا از تخریب سیستم جلوگیری شود.)

------

## **چرا `rm` فایل‌ها را به سطل آشغال نمی‌فرستد؟**

برخلاف سیستم‌عامل‌هایی مانند **ویندوز و مک** که هنگام حذف فایل‌ها ابتدا آن‌ها را به **سطل زباله (Trash/Recycle Bin)** منتقل می‌کنند، دستور `rm` در لینوکس فایل‌ها را **مستقیماً از سیستم حذف می‌کند**.

**دلایل این رفتار:**

**کارایی بالاتر:** حذف مستقیم باعث صرفه‌جویی در زمان و منابع می‌شود.

**مدیریت سرور و اسکریپت‌ها:** در محیط‌های سرور و اسکریپت‌های خودکار، ذخیره فایل‌های حذف‌شده در سطل زباله غیرمنطقی است.

**مفهوم اصلی یونیکس:** اصل طراحی لینوکس و یونیکس بر **سادگی و قدرت کنترل** است، نه ایجاد واسطه‌هایی مانند سطل زباله.

### Command `rmdir`

دستور `rmdir` در لینوکس برای **حذف دایرکتوری‌های خالی** استفاده می‌شود. این دستور فقط زمانی کار می‌کند که **دایرکتوری هیچ فایلی یا زیردایرکتوری‌ای نداشته باشد**.

#### Command `mv`

## **توضیح کامل دستور `mv` در لینوکس**

دستور `mv` در لینوکس برای **انتقال (Move) یا تغییر نام (Rename) فایل‌ها و دایرکتوری‌ها** استفاده می‌شود. این دستور **در مقایسه با `cp` سریع‌تر است**، زیرا به‌جای کپی کردن داده‌ها، فقط مسیر فایل را تغییر می‌دهد.

```bash
mv a b
```

🔹 این دستور **فایل `a` را به `b` تغییر نام می‌دهد**.
 🔹 اگر فایل `b` از قبل وجود داشته باشد، بدون هشدار با `a` جایگزین می‌شود.

✅ **مثال:**

```bash
mv oldfile.txt newfile.txt
```

📌 فایل `oldfile.txt` به `newfile.txt` تغییر نام می‌دهد.

```bash
mv a folder/b
```

🔹 این دستور **فایل `a` را به مسیر `folder/` منتقل کرده و نام آن را `b` می‌گذارد**.
 🔹 اگر `folder/` وجود نداشته باشد، خطا دریافت خواهید کرد.

✅ **مثال:**

```bash
mv document.txt myfolder/newdoc.txt
```

📌 فایل `document.txt` به دایرکتوری `myfolder/` منتقل شده و نامش به `newdoc.txt` تغییر می‌کند.

```bash
mv a ~/Desktop/b
```

🔹 این دستور **فایل `a` را به دسکتاپ منتقل کرده و آن را `b` نام‌گذاری می‌کند**.
 🔹 `~` نشان‌دهنده‌ی **پوشه‌ی خانگی (Home Directory)** کاربر است.

✅ **مثال:**

```bash
mv notes.txt ~/Desktop/notes_backup.txt
```

📌 فایل `notes.txt` به دسکتاپ منتقل شده و به `notes_backup.txt` تغییر نام می‌دهد.

```bash
mv -R video/ ~/Desktop/
```

🔹 **`-R` یا `--recursive`** باعث می‌شود دایرکتوری `video/` و تمام فایل‌های داخل آن **به دسکتاپ منتقل شوند**.
 🔹 این گزینه معمولاً **نیاز نیست**، زیرا `mv` به‌طور پیش‌فرض دایرکتوری‌ها را نیز منتقل می‌کند.

✅ **مثال:**

```bash
mv myfolder/ ~/Documents/
```

📌 کل پوشه‌ی `myfolder/` و محتوای آن به `~/Documents/` منتقل می‌شود.

```bash
mv -f a b
```

🔹 **`-f` یا `--force`** باعث می‌شود که **بدون درخواست تأیید، فایل `b` (اگر وجود داشته باشد) حذف شده و با `a` جایگزین شود**.

✅ **مثال:**

```bash
mv -f oldconfig.conf newconfig.conf
```

📌 فایل `newconfig.conf` بدون هیچ هشداری با `oldconfig.conf` جایگزین می‌شود.

```bash
mv -i a b
```

🔹 **`-i` یا `--interactive`** باعث می‌شود که **قبل از جایگزین کردن فایل مقصد، تأیید گرفته شود**.
 🔹 اگر `b` وجود داشته باشد، پیغام زیر ظاهر می‌شود:

```
mv: overwrite 'b'? (y/n)
```

- اگر `y` را بزنید، جایگزینی انجام می‌شود.
- اگر `n` را بزنید، عملیات لغو می‌شود.

✅ **مثال:**

```bash
mv -i report.pdf ~/Documents/
```

📌 اگر `report.pdf` در `~/Documents/` وجود داشته باشد، سیستم از شما تأیید می‌خواهد.

```bash
mv -u a b
```

🔹 **`-u` یا `--update`** باعث می‌شود که **فایل `a` فقط در صورتی جایگزین `b` شود که `a` جدیدتر باشد**.
 🔹 اگر `b` جدیدتر باشد، هیچ تغییری انجام نمی‌شود.

✅ **مثال:**

```bash
mv -u backup.log /var/logs/
```

📌 اگر `backup.log` جدیدتر از نسخه‌ی موجود در `/var/logs/` باشد، جایگزین خواهد شد.

#### Command `ls`

### **توضیح کامل دستور `ls` در لینوکس**

دستور `ls` برای **لیست کردن فایل‌ها و دایرکتوری‌ها** استفاده می‌شود. این دستور می‌تواند اطلاعاتی مانند **نام فایل‌ها، مجوزهای دسترسی، مالکیت، اندازه، تاریخ آخرین تغییر و نوع فایل** را نمایش دهد.

```bash
ls -a
```

🔹 **`-a` (all)** باعث می‌شود که **تمام فایل‌ها و دایرکتوری‌ها، از جمله فایل‌های مخفی** نمایش داده شوند.
 🔹 در لینوکس، فایل‌های مخفی با `.` (نقطه) شروع می‌شوند، مانند:

```
.bashrc  .profile  .gitignore  myfile.txt  folder/
```

✅ **مثال:**

```bash
ls -a ~/
```

📌 لیست تمام فایل‌ها، از جمله فایل‌های مخفی را در دایرکتوری خانه (Home) نمایش می‌دهد.

```bash
ls -al
```

🔹 ترکیب **`-a` (همه فایل‌ها) و `-l` (فرمت لیست بلند)** باعث می‌شود که **اطلاعات کامل همه‌ی فایل‌ها (از جمله فایل‌های مخفی) نمایش داده شود**.
 🔹 خروجی نمونه:

```
drwxr-xr-x  2 user  user  4096 Jan 30 12:00 Documents
-rw-r--r--  1 user  user   512 Feb 01 15:42 .bashrc
-rw-r--r--  1 user  user  1024 Feb 01 16:00 notes.txt
```

✅ اطلاعاتی که نمایش داده می‌شود:

- **نوع فایل (d برای دایرکتوری، - برای فایل معمولی)**
- **مجوزهای دسترسی (rwx)**
- **تعداد لینک‌ها (۲، ۱، و غیره)**
- **مالک فایل و گروه مالک**
- **اندازه فایل (برحسب بایت)**
- **تاریخ آخرین تغییر**
- **نام فایل**

✅ **مثال:**

```bash
ls -al /etc
```

📌 تمام فایل‌های موجود در `/etc/`، از جمله فایل‌های مخفی، با اطلاعات کامل نمایش داده می‌شوند.

```bash
ls -p
```

🔹 این گزینه **علامت `/` را به انتهای نام دایرکتوری‌ها اضافه می‌کند** تا آن‌ها را از فایل‌های معمولی تشخیص دهید.
 🔹 خروجی نمونه:

```
Documents/  Downloads/  script.sh  notes.txt
```

✅ **مثال:**

```bash
ls -p ~/
```

📌 لیست فایل‌ها و دایرکتوری‌های `home/` را نشان می‌دهد، و دایرکتوری‌ها `/` در انتهای نام دارند.

```bash
ls f*
```

🔹 **Wildcard (`\*`)** یعنی **هرچیزی که بعد از `f` بیاید** را نمایش بده.
 🔹 این دستور تمام فایل‌ها و پوشه‌هایی که نامشان با `f` شروع می‌شود را لیست می‌کند.

✅ **مثال:**

```bash
ls f*
```

📌 اگر دایرکتوری شامل این فایل‌ها باشد:

```
file1.txt  file2.txt  folder/  myfile.txt
```

خروجی این خواهد بود:

```
file1.txt  file2.txt  folder/
```

```bash
ls f?
```

🔹 **Wildcard (`?`)** یعنی **دقیقا یک کاراکتر بعد از `f` بیاید**.
 🔹 این دستور فایل‌هایی را لیست می‌کند که **نامشان با `f` شروع شده و دقیقاً یک کاراکتر بعد از آن دارند**.

✅ **مثال:**

```bash
ls f?
```

📌 اگر دایرکتوری شامل این فایل‌ها باشد:

```
fa  fb  fc  file1.txt  file2.txt  folder/
```

خروجی این خواهد بود:

```
fa  fb  fc
```

🔴 فایل‌هایی مانند `file1.txt` و `folder/` نمایش داده نمی‌شوند، چون بیش از یک کاراکتر بعد از `f` دارند.

```bash
ls -Fl
```

🔹 ترکیب **`-F` و `-l`** باعث می‌شود که:

- `-F`

   علامت خاصی به انتهای فایل‌ها اضافه کند:

  - `/` → دایرکتوری
  - `*` → فایل اجرایی
  - `@` → لینک نمادین

- **`-l`** نمایش جزئیات کامل فایل‌ها

✅ **مثال:**

```bash
ls -Fl ~/
```

📌 خروجی نمونه:

```
drwxr-xr-x  2 user user  4096 Feb 02 14:00 Documents/
-rw-r--r--  1 user user  512  Feb 01 16:00 script.sh*
lrwxrwxrwx  1 user user   20   Jan 20 12:30 mylink -> /etc/passwd
```

`Documents/` → دایرکتوری

`script.sh*` → فایل اجرایی

`mylink -> /etc/passwd` → لینک نمادین

#### Command `ln`

دستور `ln` در لینوکس برای **ایجاد لینک (پیوند) بین فایل‌ها و دایرکتوری‌ها** استفاده می‌شود. این لینک‌ها دو نوع دارند:

1. **لینک سخت (Hard Link)**: یک نسخه‌ی مستقیم از فایل ایجاد می‌کند که به همان داده‌ی اصلی اشاره دارد.
2. **لینک نمادین (Symbolic Link یا Soft Link)**: مانند یک **میان‌بر (Shortcut)** عمل می‌کند و فقط به مسیر فایل اصلی اشاره دارد.

```bash
ln file1 link1
```

🔹 این دستور **یک لینک سخت از `file1` به `link1`** ایجاد می‌کند.
 🔹 **هر دو فایل (اصلی و لینک) به یک داده‌ی فیزیکی روی دیسک اشاره می‌کنند.**
 🔹 اگر یکی از این فایل‌ها را تغییر دهید، دیگری هم تغییر خواهد کرد.
 🔹 اگر `file1` را حذف کنید، `link1` همچنان داده‌ها را نگه می‌دارد.

✅ **مثال:**

```bash
ln myfile.txt mylink.txt
```

📌 فایل `mylink.txt` یک **لینک سخت** به `myfile.txt` خواهد بود.

✅ بررسی لینک سخت:

```bash
ls -li
```

📌 هر دو فایل **شماره اینود (inode) یکسانی دارند** که نشان می‌دهد هر دو به یک داده روی دیسک اشاره دارند.

```
123456 -rw-r--r-- 2 user user 1024 Feb 01 14:00 myfile.txt
123456 -rw-r--r-- 2 user user 1024 Feb 01 14:00 mylink.txt
```

📌 مقدار `2` در ستون دوم نشان می‌دهد که دو لینک به این فایل وجود دارد.

```bash
ln -s target linkname
```

🔹 این دستور **یک لینک نمادین (میان‌بر) از `target` به `linkname`** ایجاد می‌کند.
 🔹 این لینک فقط **به مسیر فایل اصلی اشاره دارد**، و اگر فایل اصلی حذف شود، لینک دیگر کار نمی‌کند (**لینک شکسته - Broken Link**).
 🔹 می‌توان برای **دایرکتوری‌ها** نیز لینک نمادین ایجاد کرد، برخلاف لینک سخت.

✅ **مثال ۱: ایجاد لینک نمادین برای یک فایل**

```bash
ln -s /home/user/original.txt shortcut.txt
```

📌 حالا `shortcut.txt` فقط یک **اشاره‌گر (Shortcut)** به `original.txt` است.

✅ **مثال ۲: ایجاد لینک نمادین برای یک دایرکتوری**

```bash
ln -s /var/www/html mywebsite
```

📌 حالا `mywebsite` به `/var/www/html` اشاره می‌کند، و شما می‌توانید با اجرای `cd mywebsite` به همان دایرکتوری بروید.

✅ بررسی لینک نمادین:

```bash
ls -l
```

📌 خروجی نمونه:

```
lrwxrwxrwx 1 user user   12 Feb 01 14:00 shortcut.txt -> original.txt
```

- `l` در ابتدای مجوزهای فایل نشان می‌دهد که **یک لینک نمادین است**.
- `->` نشان می‌دهد که `shortcut.txt` به `original.txt` اشاره دارد.

| ویژگی                      | لینک سخت (`ln`)                         | لینک نمادین (`ln -s`)                    |
| -------------------------- | --------------------------------------- | ---------------------------------------- |
| ارتباط با فایل اصلی        | مستقیم (یک نسخه از داده‌ی واقعی)         | فقط یک اشاره‌گر (Shortcut)                |
| شماره اینود (inode)        | یکسان با فایل اصلی                      | متفاوت                                   |
| امکان لینک‌دهی به دایرکتوری | ❌ خیر                                   | ✅ بله                                    |
| وابستگی به فایل اصلی       | ✅ باقی می‌ماند حتی اگر فایل اصلی حذف شود | ❌ لینک شکسته می‌شود اگر فایل اصلی حذف شود |
| مجاز در پارتیشن‌های مختلف   | ❌ فقط در همان پارتیشن                   | ✅ در پارتیشن‌های مختلف امکان‌پذیر است      |

🔹 برای حذف لینک‌های سخت و نمادین، می‌توان از `rm` یا `unlink` استفاده کرد.

✅ **حذف لینک سخت (مانند فایل معمولی)**

```bash
rm mylink.txt
```

✅ **حذف لینک نمادین**

```bash
rm shortcut.txt
```

یا

```bash
unlink shortcut.txt
```

#### Command `tar`

اینجا یک نسخه بازنویسی‌شده و کامل‌تر از توضیحات شما آمده است:

------

**فشرده‌سازی فایل‌ها در لینوکس با استفاده از tar**

در سیستم‌عامل **لینوکس**، ابزار **tar** یکی از رایج‌ترین روش‌ها برای **بایگانی** و **فشرده‌سازی** فایل‌ها است. این ابزار به کاربران اجازه می‌دهد چندین فایل و پوشه را در یک فایل آرشیو ترکیب کرده و در صورت نیاز آن را با استفاده از **الگوریتم‌های مختلف فشرده‌سازی** کاهش حجم دهند.

**فرمت‌های فشرده‌سازی در tar**

**tar** به‌تنهایی فقط وظیفه **بایگانی کردن** (ترکیب چندین فایل در یک فایل) را بر عهده دارد و به‌طور پیش‌فرض فشرده‌سازی انجام نمی‌دهد. اما با ترکیب آن با ابزارهای فشرده‌سازی مختلف، می‌توان فایل‌های ایجادشده را فشرده کرد. برخی از فرمت‌های متداول عبارت‌اند از:

| فرمت خروجی            | الگوریتم فشرده‌سازی | توضیحات                                      |
| --------------------- | ------------------ | -------------------------------------------- |
| `.tar`                | بدون فشرده‌سازی     | تنها یک بایگانی ساده از فایل‌ها بدون کاهش حجم |
| `.tgz` یا `.tar.gz`   | gzip               | فشرده‌سازی سریع ولی با نسبت کاهش حجم متوسط    |
| `.tbz` یا `.tar.bz`   | bzip               | فشرده‌سازی با نسبت بهتر ولی سرعت کمتر         |
| `.tbz2` یا `.tar.bz2` | bzip2              | نسخه بهینه‌شده bzip با عملکرد بهتر            |
| `.txz` یا `.tar.xz`   | xz                 | بهترین نسبت فشرده‌سازی ولی سرعت پایین‌تر       |

**حفظ مالکیت و سطوح دسترسی**

یکی از ویژگی‌های مهم tar این است که هنگام **بایگانی کردن**، **مالکیت فایل‌ها** و **سطوح دسترسی** آن‌ها (شامل مجوزهای خواندن، نوشتن و اجرا) را حفظ می‌کند. این ویژگی به‌ویژه در هنگام **پشتیبان‌گیری از داده‌ها** و **انتقال فایل بین سیستم‌ها** بسیار مفید است.

**پرکاربردترین گزینه‌های tar**

زمان استفاده از **tar** معمولاً چندین **فلگ** (گزینه) برای کنترل عملکرد آن استفاده می‌شود. یکی از متداول‌ترین ترکیب‌ها عبارت است از:

```
tar -czvf archive.tar.gz directory/
```

در این دستور:

- `c` → ایجاد یک بایگانی (Create)
- `z` → فشرده‌سازی با **gzip**
- `v` → نمایش جزئیات فرآیند (Verbose)
- `f` → تعیین نام فایل خروجی

نمونه دستورات tar

ایجاد یک آرشیو فشرده‌شده با **bzip2**:

```bash
tar -cjvf backup.tar.bz2 my_folder/
```

اکسترکت کردن یک فایل فشرده‌شده با **xz**:

```bash
tar -xJvf archive.tar.xz
```

------

## 🔹 اوپراتور `>` (ریدایرکت خروجی - بازنویسی فایل)

این اوپراتور **خروجی استاندارد (stdout)** یک دستور را گرفته و در یک فایل ذخیره می‌کند. اگر فایل **وجود داشته باشد، محتوای قبلی آن حذف شده و بازنویسی می‌شود**.

📌 مثال: ذخیره خروجی در یک فایل

```bash
echo "Hello, Linux!" > output.txt
```

📌 در این مثال:
 ✅ اگر فایل `output.txt` **وجود نداشته باشد**، ایجاد می‌شود.
 ✅ اگر فایل **موجود باشد**، محتوای آن حذف شده و متن **"Hello, Linux!"** جایگزین می‌شود.

------

## 🔹 اوپراتور `>>` (ریدایرکت خروجی - اضافه کردن به فایل)

این اوپراتور مانند `>` عمل می‌کند، با این تفاوت که **محتوای جدید را به انتهای فایل اضافه می‌کند** و محتوای قبلی را **حذف نمی‌کند**.

📌 مثال: اضافه کردن به فایل

```bash
echo "This is a new line" >> output.txt
```

✅ این دستور، **خط جدیدی** را به انتهای `output.txt` اضافه می‌کند، بدون اینکه داده‌های قبلی را از بین ببرد.

------

## 🔹 اوپراتور `|` (پایپ - ارسال خروجی یک دستور به ورودی دستور دیگر)

اوپراتور **`|`** (پایپ) خروجی یک دستور را **مستقیماً به ورودی دستور دیگر می‌فرستد**، بدون نیاز به ذخیره‌سازی در فایل.

📌 مثال: نمایش فقط دایرکتوری‌ها با استفاده از `ls` و `grep`

```bash
ls -l | grep "^d"
```

✅ در اینجا، دستور `ls -l` **لیست فایل‌ها و دایرکتوری‌ها** را نمایش می‌دهد، سپس `grep "^d"` فقط **آن‌هایی که با `d` شروع می‌شوند** (دایرکتوری‌ها) را فیلتر می‌کند.

------

## 🔥 ترکیب چند اوپراتور

ذخیره خروجی یک دستور فیلتر شده در فایل:

```bash
ls -l | grep "^d" > directories.txt
```

✅ لیست دایرکتوری‌ها را در فایل `directories.txt` ذخیره می‌کند.

شمارش تعداد فایل‌های `.txt` در یک دایرکتوری:

```bash
ls *.txt | wc -l
```

✅ `ls *.txt` لیست فایل‌های متنی را نمایش می‌دهد، سپس `wc -l` تعداد خطوط (فایل‌ها) را می‌شمارد.

#### Xargs

برای اینکه خروجی یک فرمان (command) به عنوان ورودی فرمان دیگری استفاده شود، می‌توان از روش‌های مختلفی بهره برد. در ادامه سه روش متداول توضیح داده شده است:

استفاده از **Pipe (`|`) و `xargs`**

```bash
ls | xargs rm
```

در این روش:

`ls` لیست فایل‌ها و دایرکتوری‌های موجود در دایرکتوری جاری را نمایش می‌دهد.

`|` (Pipe) خروجی `ls` را به عنوان ورودی به دستور `xargs` می‌دهد.

`xargs rm` دستور `rm` را برای هر یک از ورودی‌های دریافت‌شده اجرا می‌کند و آن‌ها را حذف می‌کند.

------

استفاده از **بک‌تیک‌ها (`` ` ` `)**

```bash
rm `ls`
```

در این روش:

`ls` اجرا شده و خروجی آن (لیست فایل‌ها) به عنوان آرگومان به دستور `rm` داده می‌شود.

سپس `rm` آن فایل‌ها را حذف می‌کند.

 استفاده از **$() (جایگزین مدرن‌تر بک‌تیک)**

```bash
rm $(ls)
```

این روش مشابه روش قبل است، اما استفاده از `$()` به جای `` `` توصیه می‌شود زیرا خواناتر و قابل‌اعتمادتر است.



####  Command `zip`

```bash
zip file.zip d.txt
```

✅ این دستور فایل **`d.txt`** را فشرده کرده و داخل **`file.zip`** قرار می‌دهد.

اگر `file.zip` وجود نداشته باشد، یک فایل جدید ایجاد می‌شود.

اگر `file.zip` از قبل وجود داشته باشد، `d.txt` به آن اضافه می‌شود، مگر اینکه گزینه `-r` برای بازنویسی استفاده شود.

اگر فایلی که می‌خواهید اضافه کنید، وجود نداشته باشد، خطا نمایش داده می‌شود.

## فشرده‌سازی چندین فایل همزمان

```bash
zip file.zip *.txt
```

✅ این دستور **همه‌ی فایل‌های متنی (`.txt`)** را در دایرکتوری جاری داخل فایل `file.zip` فشرده می‌کند.

- `*.txt` به معنی **همه فایل‌هایی است که پسوند `.txt` دارند**.
- اگر هیچ فایل `.txt` در دایرکتوری موجود نباشد، ممکن است پیغام خطا دریافت کنید.

------

## فشرده‌سازی یک دایرکتوری به‌صورت بازگشتی

```bash
zip -r directory.zip directory
```

✅ این دستور کل **محتویات دایرکتوری** (از جمله فایل‌ها و زیردایرکتوری‌ها) را داخل `directory.zip` فشرده می‌کند.

- `-r` مخفف **recursive** (بازگشتی) است و باعث می‌شود کل دایرکتوری همراه با محتویاتش فشرده شود.
- اگر `directory` شامل زیرپوشه‌هایی باشد، آن‌ها نیز داخل فایل فشرده قرار خواهند گرفت.

💡 **مثال:**
 فرض کنید دایرکتوری `project` شامل موارد زیر باشد:

```
project/
├── file1.txt
├── file2.txt
└── subdir/
    └── file3.txt
```

پس از اجرای:

```bash
zip -r project.zip project
```

یک فایل `project.zip` ایجاد می‌شود که شامل **همه‌ی این فایل‌ها و فولدرها** خواهد بود.

------

## استخراج فایل‌های فشرده‌شده (باز کردن فایل ZIP)

```bash
unzip file.zip
```

✅ این دستور فایل `file.zip` را **استخراج (اکسترکت)** می‌کند و محتویات آن را در دایرکتوری جاری قرار می‌دهد.

- اگر فایل‌های موجود در `file.zip` از قبل در دایرکتوری مقصد وجود داشته باشند، **سیستم از شما می‌پرسد که آیا می‌خواهید آن‌ها را جایگزین کنید یا نه.**

- اگر می‌خواهید بدون پرسش، همه فایل‌ها را بازنویسی کنید، از گزینه 

  ```
  -o
  ```

   استفاده کنید:

  ```bash
  unzip -o file.zip
  ```

- اگر می‌خواهید فایل‌ها را در یک دایرکتوری خاص استخراج کنید، از گزینه 

  ```
  -d
  ```

   استفاده کنید:

  ```bash
  unzip file.zip -d my_folder
  ```

  این دستور فایل‌ها را در دایرکتوری 

  ```
  my_folder/
  ```

   استخراج می‌کند.

#### Command `bzip2`

دستور `bzip2` برای فشرده‌سازی فایل‌ها در سیستم‌عامل‌های مبتنی بر یونیکس و لینوکس استفاده می‌شود. این دستور فایل اصلی را پس از فشرده‌سازی حذف می‌کند، مگر اینکه از گزینه‌های خاصی برای حفظ فایل اصلی استفاده شود.

 در یک دایرکتوری:

```sh
bzip2 *.jpg
```

 از حالت فشرده و بازیابی نسخه اصلی آن:

```sh
bunzip2 file.txt.bz2
```

#### Command `gzip`

دستور `gzip` برای فشرده‌سازی فایل‌ها در سیستم‌عامل‌های مبتنی بر یونیکس و لینوکس استفاده می‌شود. این دستور فایل اصلی را پس از فشرده‌سازی حذف می‌کند، مگر اینکه از گزینه‌های خاصی برای حفظ فایل اصلی استفاده شود.

 در یک دایرکتوری:

```sh
gzip *.jpg
```

 از حالت فشرده و بازیابی نسخه اصلی آن:

```sh
gunzip file.txt.bz2
```

#### Command `head`

این دستور 10 خط اول یک فایل را نسان می دهد.

#### Command `tail`

این دستور 10 خط آخر یک فایل را نشان می دهد.

#### Command cut

این دستور قسمتی از متن را انتخاب می کند.

```
cut [OPTIONS] [FILE]
```

✅ **`OPTIONS`** → گزینه‌های مختلف برای مشخص کردن نوع برش
 ✅ **`FILE`** → نام فایل متنی (یا ورودی از `stdin`)

------

## **🔹 کاربردهای پرکاربرد `cut`**

**1️⃣ برش بر اساس موقعیت بایت‌ها (`-b`)**

با گزینه `-b` می‌توان **بایت‌های خاصی از هر خط را استخراج کرد**:

```bash
echo "Hello Linux" | cut -b 1-5
```

✅ خروجی:

```
Hello
```

🔹 این دستور **5 بایت اول** (`H`, `e`, `l`, `l`, `o`) را استخراج می‌کند.

💡 **نکته:** `-b` برای **حروف UTF-8** همیشه دقیق نیست، چون برخی کاراکترها بیش از 1 بایت دارند!

------

**2️⃣ برش بر اساس کاراکتر (`-c`)**

برای انتخاب **کاراکترهای خاصی از هر خط** از `-c` استفاده کنید:

```bash
echo "Linux is great" | cut -c 1,6,9
```

✅ خروجی:

```
Lig
```

🔹 این دستور **کاراکترهای 1، 6 و 9** را نمایش می‌دهد (`L`, `i`, `g`).

------

**3️⃣ برش بر اساس فیلد (`-f`) و جداکننده (`-d`)**

این روش بسیار پرکاربرد است، مخصوصاً هنگام کار با **فایل‌های CSV یا خروجی‌های جدولی**.

📌 **نمونه داده (`data.txt`)**:

```
1,Ali,Developer
2,Sara,Designer
3,Omid,Manager
```

**📌 استخراج فقط نام‌ها (ستون دوم)**

```bash
cut -d ',' -f 2 data.txt
```

✅ خروجی:

```
Ali
Sara
Omid
```

🔹 **`-d ','`** → مشخص کردن جداکننده (`,`)
 🔹 **`-f 2`** → نمایش فقط **فیلد دوم**

------

## **🔹 محدودیت‌های `cut`**

1️⃣ `cut` **فقط روی متن ساده** کار می‌کند و **عبارات منظم (Regex)** را پشتیبانی نمی‌کند.
 2️⃣ `cut` نمی‌تواند فیلدهای **متغیرطول** (مثلاً فاصله‌های نامرتب) را به‌خوبی پردازش کند.
 3️⃣ برای پردازش‌های پیچیده‌تر، ابزار **`awk`** یا **`sed`** بهتر است.

#### Command `find`

دستور **`find`** در لینوکس یکی از **ابزارهای قدرتمند برای جستجو** در فایل‌ها و دایرکتوری‌ها است. این دستور می‌تواند **بر اساس نام، نوع، اندازه، زمان تغییر، سطح دسترسی و بسیاری از ویژگی‌های دیگر**، فایل‌ها را پیدا کند.

------

## **🔹 ساختار کلی دستور `find`**

```
find [path] [options] [expression]
```

✅ **`path`** → (اختیاری) مسیر دایرکتوری‌ای که می‌خواهید جستجو را از آنجا شروع کنید.
 ✅ **`options`** → (اختیاری) مشخص‌کننده نوع جستجو (مثلاً `-name`، `-type`، `-size` و ...)
 ✅ **`expression`** → (اختیاری) شرطی که باید بر روی فایل‌ها اعمال شود.

------

## **📌 1️⃣ دستور `find` بدون هیچ گزینه‌ای**

```bash
find
```

✅ این دستور، **تمام فایل‌ها و دایرکتوری‌های موجود در دایرکتوری جاری (و زیرشاخه‌های آن)** را لیست می‌کند.
 ✅ معادل:

```bash
find .
```

🔹 نقطه `.` یعنی **دایرکتوری فعلی**.

------

## **📌 2️⃣ جستجو در کل سیستم (`find /`)**

```bash
find /
```

✅ این دستور، جستجو را از **`/` (ریشه سیستم)** آغاز می‌کند.
 ✅ از آنجایی که `/` شامل **همه فایل‌های سیستم‌عامل** است، ممکن است **زمان زیادی طول بکشد**.
 ✅ معادل:

```bash
find /
```

💡 **نکته:** برای **اجتناب از خطاهای دسترسی**، می‌توان از `sudo` استفاده کرد:

```bash
sudo find /
```

------

## **📌 3️⃣ جستجوی تمام فایل‌ها (`find -type f`)**

```bash
find -type f
```

✅ این دستور، **تمام فایل‌های معمولی** را در دایرکتوری جاری (و زیرشاخه‌ها) پیدا می‌کند.
 ✅ معادل:

```bash
find . -type f
```

🔹 `-type f` → فقط **فایل‌های معمولی** (`f = file`) را نمایش می‌دهد.

------

## **📌 4️⃣ جستجو بر اساس نام (`find -name "file\*"`)**

```bash
find -name "file*"
```

✅ این دستور **تمام فایل‌ها و دایرکتوری‌هایی که نامشان با `file` شروع می‌شود** را جستجو می‌کند.
 ✅ مثال:

```bash
find -name "test.txt"
```

🔹 فقط **`test.txt`** را پیدا می‌کند (با رعایت حروف کوچک و بزرگ).

------

## **📌 5️⃣ جستجو بر اساس نام و نوع (`find -type f -name "file\*"`)**

```bash
find -type f -name "file*"
```

✅ این دستور **فقط فایل‌هایی که نامشان با "file" شروع می‌شود** را پیدا می‌کند.
 ✅ مثال:

```bash
find /home -type f -name "*.log"
```

🔹 فقط **فایل‌های `.log`** را در `/home` جستجو می‌کند.

------

## **📌 خلاصه دستورات بررسی‌شده**

| دستور                        |                            توضیح                             |
| ---------------------------- | :----------------------------------------------------------: |
| `find`                       |        لیست کردن همه فایل‌ها و پوشه‌های داخل مسیر جاری         |
| `find /`                     |               جستجو در کل سیستم از `/` (ریشه)                |
| `find -type f`               |                  جستجوی تمام فایل‌های معمولی                  |
| `find -name "file*"`         | جستجوی فایل‌ها و دایرکتوری‌هایی که نامشان با "file" شروع می‌شود |
| `find -type f -name "file*"` |      جستجوی فقط فایل‌هایی که نامشان با "file" شروع می‌شود      |

## مدیریت و اجرای پردازش‌ها در لینوکس

در سیستم‌عامل لینوکس، هر پردازش (Process) به دو حالت **والد (Parent)** و **فرزند (Child)** تقسیم می‌شود. زمانی که یک پردازش جدید ایجاد می‌شود، در واقع یک پردازش فرزند از یک پردازش والد منشعب می‌شود. این سلسله‌مراتب پردازش‌ها باعث مدیریت بهتر منابع و ارتباط بین پردازش‌ها در سیستم‌عامل می‌شود.

## **ارتباط بین پردازش‌ها (Parent و Child)**

- هر پردازش در سیستم لینوکس دارای یک شناسه‌ی منحصر‌به‌فرد به نام **PID** (Process ID) است که سیستم از طریق آن پردازش‌ها را مدیریت می‌کند.
- پردازش‌های فرزند توسط یک پردازش والد ایجاد شده و دارای یک شناسه‌ی والد به نام **PPID** (Parent Process ID) هستند که نشان می‌دهد پردازش موردنظر توسط کدام پردازش ایجاد شده است.
- اگر یک پردازش والد بسته شود، معمولاً پردازش‌های فرزند آن نیز بسته خواهند شد، مگر اینکه این پردازش‌ها به صورت خاصی طراحی شده باشند که در صورت از بین رفتن والد، همچنان به فعالیت خود ادامه دهند.

## **نقش پردازش init**

- پردازش `init` اولین پردازشی است که هنگام بوت شدن سیستم اجرا می‌شود و از آن‌جایی که مستقیماً توسط کرنل اجرا می‌شود، **والدی ندارد**.
- شناسه پردازشی `init` همواره **۱** است و وظیفه آن مدیریت پردازش‌های سطح بالا و راه‌اندازی سایر پردازش‌های سیستم است.

## **اولویت‌بندی پردازش‌ها و PID**

- هرچه مقدار **PID** یک پردازش **بزرگ‌تر** باشد، اولویت اجرای آن در پردازنده **کم‌تر** خواهد بود.
- سیستم‌عامل از یک **سیاست زمان‌بندی (Scheduling Policy)** برای تخصیص منابع پردازشی به پردازش‌ها استفاده می‌کند که اولویت را مشخص می‌کند.

------

## **پردازش‌های زامبی (Zombie Process)**

پردازش‌های زامبی، پردازش‌هایی هستند که والد آن‌ها از بین رفته، اما خودشان هنوز در سیستم باقی مانده‌اند.

### **بررسی فایل‌های لاگ (Log) مهم در لینوکس**

در سیستم‌عامل لینوکس، **فایل‌های لاگ (Log Files)** برای ذخیره اطلاعات مربوط به عملکرد سیستم، سرویس‌ها، خطاها و رخدادهای مختلف مورد استفاده قرار می‌گیرند. این فایل‌ها در مسیر `/var/log/` ذخیره می‌شوند و به مدیر سیستم کمک می‌کنند تا مشکلات را شناسایی کرده و فرآیندهای سیستم را پایش کنند.

در ادامه، توضیحاتی درباره برخی از فایل‌های لاگ مهم آورده شده است:

------

###  boot.log

**کاربرد:** این فایل اطلاعات مربوط به فرآیند **راه‌اندازی (Booting)** سیستم را ذخیره می‌کند.

**جزئیات:**

شامل پیام‌هایی است که هنگام بوت شدن سیستم توسط سرویس‌های مختلف نوشته می‌شود.

می‌توان از این لاگ برای بررسی مشکلاتی که هنگام راه‌اندازی سیستم رخ داده‌اند، استفاده کرد.

**مشاهده محتوا:**

```bash
cat /var/log/boot.log
```

یا

```bash
less /var/log/boot.log
```

------

### **cron**

**کاربرد:** مربوط به سرویس **Cron** است که برای زمان‌بندی و اجرای خودکار وظایف (Jobs) در زمان‌های مشخص استفاده می‌شود.

**جزئیات:**

شامل گزارش‌هایی از وظایف زمان‌بندی شده‌ای است که در پس‌زمینه اجرا شده‌اند.

اگر یک کار زمان‌بندی شده اجرا نشود یا با خطا مواجه شود، این فایل اطلاعاتی درباره آن ارائه می‌دهد.

**مشاهده محتوا:**

```bash
cat /var/log/cron
```

------

### **gdm**

**کاربرد:** این فایل مربوط به **GNOME Display Manager (GDM)** است که برای مدیریت صفحه ورود کاربران (Login Screen) در محیط دسکتاپ GNOME استفاده می‌شود.

**جزئیات:**

شامل اطلاعاتی درباره ورود و خروج کاربران از سیستم است.

اگر مشکلی در ورود به سیستم گرافیکی وجود داشته باشد، این فایل می‌تواند به شناسایی علت مشکل کمک کند.

**مشاهده محتوا:**

```bash
cat /var/log/gdm
```

------

### messages

**کاربرد:** یکی از فایل‌های عمومی و مهم در لینوکس است که حاوی پیام‌های کلی سیستم و سرویس‌های مختلف می‌باشد.

**جزئیات:**

در بسیاری از توزیع‌های لینوکس، این فایل حاوی اطلاعات کلی از رخدادهای مختلف سیستم است.

شامل اطلاعاتی درباره سخت‌افزار، درایورها، و سرویس‌هایی که در حال اجرا هستند.

**مشاهده محتوا:**

```bash
cat /var/log/messages
```

یا

```bash
tail -f /var/log/messages
```

(برای مشاهده پیام‌های جدید به صورت زنده)

------

### **syslog**

**کاربرد:** این فایل یکی از اصلی‌ترین فایل‌های ثبت رویدادها در لینوکس است و شامل اطلاعات عمومی و سیستمی درباره سرویس‌ها و برنامه‌های مختلف است.

**جزئیات:**

برای نظارت بر عملکرد کلی سیستم و تشخیص مشکلات استفاده می‌شود.

سرویس‌های مختلف مانند شبکه، کرنل و برنامه‌های کاربری پیام‌های خود را در این فایل ثبت می‌کنند.

**مشاهده محتوا:**

```bash
cat /var/log/syslog
```

یا

```bash
tail -f /var/log/syslog
```

------

### **secure**

**کاربرد:** این فایل برای ثبت رویدادهای امنیتی سیستم مانند تلاش‌های ورود موفق و ناموفق استفاده می‌شود.

**جزئیات:**

اگر کسی تلاش کند به سیستم وارد شود (از طریق SSH یا کنسول)، این اطلاعات در این فایل ذخیره می‌شود.

می‌توان از این فایل برای شناسایی حملات Brute Force و تلاش‌های ورود غیرمجاز استفاده کرد.

**مشاهده محتوا:**

```bash
cat /var/log/secure
```

------

### **Xorg.0.log**

**کاربرد:** مربوط به **Xorg** (سرور گرافیکی لینوکس) است و اطلاعاتی درباره وضعیت و مشکلات مرتبط با محیط گرافیکی ارائه می‌دهد.

**جزئیات:**

اگر مشکلی در نمایشگر، کارت گرافیک یا درایورهای گرافیکی وجود داشته باشد، این فایل اطلاعات مفیدی ارائه می‌دهد.

در صورت مشکلاتی مانند صفحه سیاه هنگام بوت یا خرابی در اجرای محیط گرافیکی، بررسی این فایل ضروری است.

**مشاهده محتوا:**

```bash
cat /var/log/Xorg.0.log
```

## **مدیریت بسته‌ها در لینوکس با dpkg**

**dpkg** یک نرم‌افزار مدیریت بسته (Package Manager) برای توزیع‌های مبتنی بر **دبیان (Debian)** مانند **Ubuntu، Kali Linux، Linux Mint** و دیگر سیستم‌عامل‌های مرتبط است. این ابزار به صورت آفلاین کار می‌کند و به کاربر اجازه می‌دهد بسته‌های `.deb` را روی سیستم نصب، حذف یا بررسی کند.

با این حال، **dpkg** یک ابزار مدیریت وابستگی (Dependency Management) ندارد؛ به این معنا که اگر یک نرم‌افزار برای اجرا به بسته‌های جانبی نیاز داشته باشد، `dpkg` آن‌ها را به‌طور خودکار نصب نمی‌کند و فرآیند نصب با خطا مواجه خواهد شد. به همین دلیل، استفاده از **مدیر بسته‌های پیشرفته‌تر مانند APT** برای نصب توصیه می‌شود، اما `dpkg` همچنان برای **مشاهده، مدیریت، و حذف بسته‌ها** ابزار مفیدی است.

## **دستورات مهم dpkg**

**نمایش لیست تمامی بسته‌های نصب‌شده**

```bash
dpkg -l
```

🔹 این دستور **لیستی از تمامی بسته‌های نصب‌شده** در سیستم را نمایش می‌دهد. خروجی آن شامل نام بسته، نسخه، و توضیح کوتاهی درباره آن است.

**نمایش اطلاعات جزئی درباره یک بسته مشخص**

```bash
dpkg -p <package_name>
```

🔹 این دستور **جزئیات یک بسته خاص** را نمایش می‌دهد، از جمله نسخه، توضیحات، و وابستگی‌های آن.

**بررسی اینکه یک فایل خاص متعلق به کدام بسته است**

```bash
dpkg -S <file_name>
```

🔹 اگر بخواهید بدانید **یک فایل خاص در سیستم مربوط به کدام بسته است**، می‌توانید این دستور را استفاده کنید.

**نصب یک بسته .deb**

```bash
dpkg -i <package_name>.deb
```

🔹 این دستور برای **نصب بسته‌های محلی `.deb`** استفاده می‌شود.
 ⚠️ **اگر این بسته به پکیج‌های دیگری نیاز داشته باشد، نصب با خطا مواجه خواهد شد.** برای حل این مشکل، پس از اجرای این دستور، می‌توان با استفاده از دستور زیر وابستگی‌های آن را نصب کرد:

```bash
sudo apt-get install -f
```

**حذف یک بسته بدون پاک کردن تنظیمات آن**

```bash
dpkg -r <package_name>
```

🔹 این دستور **بسته را حذف می‌کند، اما فایل‌های پیکربندی آن را نگه می‌دارد** تا در صورت نصب مجدد، تنظیمات قبلی حفظ شوند.

**حذف کامل یک بسته (همراه با فایل‌های پیکربندی)**

```bash
dpkg -P <package_name>
```

🔹 این دستور **بسته را به طور کامل حذف می‌کند، شامل تمامی فایل‌های پیکربندی آن**.

**نمایش لیست فایل‌های داخل یک بسته نصب‌شده**

```bash
dpkg -L <package_name>
```

🔹 اگر بخواهید بدانید **یک بسته پس از نصب چه فایل‌هایی در سیستم قرار داده است**، از این دستور استفاده کنید.

**تنظیم مجدد یک بسته نصب‌شده**

```bash
dpkg-reconfigure <package_name>
```

🔹 این دستور **فرآیند پیکربندی اولیه یک بسته را دوباره اجرا می‌کند**.

 🔹 معمولاً برای **بسته‌هایی که دارای تنظیمات گرافیکی یا متنی خاصی هستند** استفاده می‌شود.

 🔹 به عنوان مثال، اگر زبان کیبورد یا تنظیمات شبکه را اشتباه وارد کرده باشید، می‌توانید این تنظیمات را با `dpkg-reconfigure` اصلاح کنید.

## **مدیریت بسته‌ها در لینوکس با APT**

**APT (Advanced Package Tool)** یک ابزار مدیریت بسته در توزیع‌های **دبیان (Debian)** و سیستم‌عامل‌های مبتنی بر آن مانند **Ubuntu، Kali Linux، Linux Mint** است. این ابزار برای **نصب، به‌روزرسانی، ارتقا و حذف بسته‌ها** از مخازن آنلاین و یا بسته‌های محلی `.deb` استفاده می‌شود.

برخلاف `dpkg`، ابزار `apt-get` به صورت **خودکار وابستگی‌های (Dependencies) لازم را مدیریت کرده و نصب می‌کند**. این ویژگی باعث می‌شود `apt-get` روش اصلی برای مدیریت بسته‌ها در لینوکس باشد.

در ادامه، مهم‌ترین دستورات `apt-get` را توضیح می‌دهیم:

**نصب یک بسته جدید**

```bash
sudo apt-get install <package_name>
```

🔹 این دستور یک **بسته را از مخازن رسمی لینوکس دریافت و نصب می‌کند**.
 🔹 همچنین **تمام وابستگی‌های لازم برای اجرای بسته را نیز نصب خواهد کرد**.

✅ **مثال:** نصب مرورگر فایرفاکس

```bash
sudo apt-get install firefox
```

**بروزرسانی لیست مخازن و اطلاعات بسته‌ها**

```bash
sudo apt-get update
```

🔹 این دستور **لیست بسته‌های موجود در مخازن را به‌روزرسانی می‌کند**، اما بسته‌های نصب‌شده را تغییر نمی‌دهد.
 🔹 این کار **قبل از ارتقا یا نصب بسته‌های جدید ضروری است**، زیرا آخرین نسخه‌ها را از مخازن دریافت می‌کند.

✅ **مثال:** اجرای به‌روزرسانی مخازن

```bash
sudo apt-get update
```

## 

**بروزرسانی همه بسته‌های نصب‌شده**

```bash
sudo apt-get upgrade
```

🔹 این دستور **تمام بسته‌هایی که نسخه جدید دارند را ارتقا می‌دهد** اما **وابستگی‌های جدید اضافه نمی‌کند**.
 🔹 اگر بسته‌ای نیاز به نصب وابستگی‌های جدید داشته باشد، این دستور آن را ارتقا نمی‌دهد.

✅ **مثال:** ارتقای تمامی بسته‌های نصب‌شده

```bash
sudo apt-get upgrade
```

**بروزرسانی تمامی بسته‌ها و مدیریت وابستگی‌ها**

```bash
sudo apt-get dist-upgrade
```

🔹 این دستور مانند `apt-get upgrade` عمل می‌کند اما **در صورت نیاز، وابستگی‌های جدید را نیز نصب کرده یا بسته‌های غیرضروری را حذف می‌کند**.
 🔹 در واقع، این روش برای ارتقای سیستم به‌صورت کامل **توصیه می‌شود**.

✅ **مثال:** بروزرسانی کامل سیستم

```bash
sudo apt-get dist-upgrade
```

**حذف یک بسته نصب‌شده (بدون حذف تنظیمات آن)**

```bash
sudo apt-get remove <package_name>
```

🔹 این دستور بسته موردنظر را **حذف می‌کند اما تنظیمات آن را نگه می‌دارد**.
 🔹 در صورتی که بخواهید بعداً بسته را دوباره نصب کنید، تنظیمات قبلی همچنان در سیستم باقی می‌مانند.

✅ **مثال:** حذف ویرایشگر Vim

```bash
sudo apt-get remove vim
```

**حذف بسته‌ها به همراه تنظیمات و وابستگی‌های غیرضروری**

```bash
sudo apt-get autoremove
```

🔹 این دستور **بسته‌هایی که دیگر موردنیاز نیستند (وابستگی‌هایی که دیگر هیچ برنامه‌ای از آن‌ها استفاده نمی‌کند) را حذف می‌کند**.
 🔹 این کار باعث **آزادسازی فضای دیسک و بهینه‌سازی سیستم** می‌شود.

✅ **مثال:** حذف بسته‌های غیرضروری

```bash
sudo apt-get autoremove
```

## **اجرای چند دستور پشت سر هم در لینوکس با `&&` و `;`**

در لینوکس، می‌توان **چندین دستور را در یک خط** با استفاده از عملگرهای مختلف اجرا کرد. دو مورد رایج برای این کار **`&&` (AND) و `;` (Semicolon)** هستند. این دو عملگر **رفتار متفاوتی در مواجهه با خطا دارند** که در ادامه به بررسی آن‌ها می‌پردازیم.

------

## **استفاده از `&&` (AND) برای اجرای دستورات به‌صورت شرطی**

```bash
command1 && command2
```

🔹 این دستور باعث می‌شود که **`command2` تنها در صورتی اجرا شود که `command1` بدون خطا اجرا شده باشد**.
 🔹 به عبارتی، اگر **`command1` موفق اجرا شود (`exit status = 0`)، `command2` اجرا خواهد شد**؛ اما اگر `command1` با خطا مواجه شود، `command2` اجرا نمی‌شود.

✅ **مثال:** ایجاد یک پوشه و سپس ورود به آن

```bash
mkdir my_folder && cd my_folder
```

🔹 اگر پوشه `my_folder` **با موفقیت ایجاد شود**، دستور `cd my_folder` اجرا خواهد شد.
 🔹 اما اگر پوشه **قبلاً وجود داشته باشد یا ایجاد آن با خطا مواجه شود، دستور `cd` اجرا نمی‌شود**.

------

## **استفاده از `;` (Semicolon) برای اجرای دستورات مستقل از یکدیگر**

```bash
command1 ; command2
```

🔹 در این روش، **`command2` بدون توجه به نتیجه `command1` اجرا می‌شود**.
 🔹 به عبارتی، حتی اگر `command1` **با خطا مواجه شود (`exit status ≠ 0`)، باز هم `command2` اجرا خواهد شد**.

✅ **مثال:** ایجاد یک پوشه و سپس نمایش لیست فایل‌ها

```bash
mkdir my_folder ; ls -l
```

🔹 حتی اگر `mkdir my_folder` **با خطا مواجه شود** (مثلاً اگر پوشه از قبل وجود داشته باشد)، دستور `ls -l` **اجرا خواهد شد**.

## **دستورات `apt-cache` در لینوکس و کاربرد آن‌ها**

`apt-cache` یکی از ابزارهای مدیریت بسته در لینوکس است که به شما امکان می‌دهد **اطلاعات کاملی درباره بسته‌های موجود در مخازن** را مشاهده کنید. برخلاف `apt-get` که برای نصب و حذف بسته‌ها استفاده می‌شود، `apt-cache` بیشتر برای **جستجو، بررسی وابستگی‌ها و نمایش جزئیات بسته‌ها** به کار می‌رود.

در ادامه، پرکاربردترین دستورات `apt-cache` و نحوه استفاده از آن‌ها را بررسی می‌کنیم.

## **نمایش اطلاعات کلی درباره `apt-cache`**

```bash
apt-cache --help
```

🔹 این دستور لیستی از تمام گزینه‌های موجود در `apt-cache` را نمایش می‌دهد.

**جستجوی یک بسته خاص**

```bash
apt-cache search <package_name>
```

🔹 این دستور **بسته‌های مرتبط با کلمه جستجو شده را نمایش می‌دهد**.
 🔹 خروجی شامل **نام بسته و توضیح کوتاهی درباره آن** است.

✅ **مثال:** جستجوی تمامی بسته‌های مرتبط با `firefox`

```bash
apt-cache search firefox
```

🔹 این دستور لیستی از بسته‌های مرتبط مانند `firefox`, `firefox-esr`, `firefox-locale-en` و ... را نمایش می‌دهد.

**نمایش مشخصات کامل یک بسته**

```bash
apt-cache show <package_name>
```

🔹 این دستور اطلاعاتی مانند **نسخه، توضیحات، وابستگی‌ها، مخزن، اندازه بسته و معماری (architecture)** را نمایش می‌دهد.

✅ **مثال:** نمایش اطلاعات بسته `vim`

```bash
apt-cache show vim
```

🔹 خروجی شامل اطلاعات زیر خواهد بود:

نام بسته

نسخه

معماری

وابستگی‌ها

توضیحات کوتاه و بلند درباره بسته

**نمایش بسته‌های مورد نیاز (Dependencies)**

```bash
apt-cache depends <package_name>
```

🔹 این دستور **لیستی از بسته‌هایی که یک بسته برای اجرا به آن‌ها نیاز دارد را نمایش می‌دهد**.
 🔹 این وابستگی‌ها شامل مواردی مانند **کتابخانه‌ها، ابزارهای مرتبط و پکیج‌های مکمل** هستند.

✅ **مثال:** بررسی وابستگی‌های بسته `vlc`

```bash
apt-cache depends vlc
```

🔹 خروجی ممکن است شامل مواردی مانند زیر باشد:

```
Depends: libvlc-bin
Depends: libvlc5
Depends: libvlccore9
Depends: vlc-bin
Depends: vlc-plugin-base
```

🔹 این یعنی `vlc` برای اجرا به این بسته‌ها نیاز دارد.

**نمایش بسته‌هایی که به این بسته وابسته‌اند (Reverse Dependencies)**

```bash
apt-cache rdepends <package_name>
```

🔹 این دستور **برعکس `apt-cache depends` عمل می‌کند** و لیستی از بسته‌هایی را نمایش می‌دهد که **برای اجرا به بسته مورد نظر نیاز دارند**.
 🔹 این دستور به شما کمک می‌کند بفهمید **اگر یک بسته را حذف کنید، چه بسته‌های دیگری ممکن است تحت تأثیر قرار بگیرند**.

✅ **مثال:** نمایش بسته‌هایی که به `libc6` وابسته هستند

```bash
apt-cache rdepends libc6
```

🔹 خروجی ممکن است شامل بسته‌هایی مانند `gcc`, `bash`, `python3`, `systemd` و موارد دیگر باشد، چون بسیاری از این بسته‌ها برای اجرا به `libc6` نیاز دارند.

**نمایش تعداد بسته‌های موجود در کش مخزن**

```bash
apt-cache stats
```

🔹 این دستور اطلاعات آماری از **تعداد بسته‌های موجود در کش سیستم** را نمایش می‌دهد، مانند:

```
Total package names: 64520
Total dependencies: 250340
Total package names in cache: 64520
```

🔹 این اطلاعات نشان می‌دهند که سیستم شما در حال حاضر **چند بسته مختلف در لیست مخازن خود دارد**.

### Command `ps`

دستور `ps` (Process Status) در لینوکس برای نمایش اطلاعات مربوط به پردازه‌های (Processes) در حال اجرا استفاده می‌شود. این دستور اطلاعات مفیدی مانند شناسه پردازه (PID)، وضعیت اجرا، میزان استفاده از پردازنده و حافظه، نام کاربری اجراکننده پردازه و مسیر اجرای برنامه را نشان می‌دهد.

به‌طور پیش‌فرض، اجرای `ps` بدون هیچ گزینه‌ای، فقط پردازه‌های مرتبط با ترمینال فعلی را نمایش می‌دهد. مثلاً:

```sh
ps
```

خروجی:

```
  PID TTY          TIME CMD
 1234 pts/0    00:00:00 bash
 5678 pts/0    00:00:00 ps
```

**توضیح ستون‌ها:**

- **PID**: شناسه پردازه (Process ID)
- **TTY**: ترمینال کنترل‌کننده پردازه
- **TIME**: مدت زمان استفاده از پردازنده
- **CMD**: نام دستوری که پردازه را اجرا کرده است

------

## بررسی برخی از گزینه‌های مهم `ps`

**`a-`**
 این گزینه تمام پردازه‌ها را نمایش می‌دهد، بجز پردازه‌های گروه‌های دیگر که به ترمینال متصل نیستند.

```sh
ps -a
```

**`T-`**
 تمام پردازه‌های مرتبط با ترمینال جاری را نمایش می‌دهد.

```sh
ps -T
```

**`r-`**
 فقط پردازه‌های در حال اجرا (Running) را نمایش می‌دهد.

```sh
ps -r
```

**`x-`**
 علاوه بر پردازه‌های کاربر، پردازه‌هایی که به هیچ ترمینالی متصل نیستند (مثلاً پردازه‌های سرویسی) را نیز نمایش می‌دهد.

```sh
ps -x
```

**`f-`**
 خروجی را در فرمت "Full" نمایش می‌دهد، یعنی اطلاعات بیشتری مانند والد پردازه (PPID) و آرگومان‌های اجرا را نمایش می‌دهد.

```sh
ps -f
```

**`L-`**
 تمام نخ‌های (Threads) مرتبط با یک پردازه را نمایش می‌دهد.

```sh
ps -L
```

**`aux-`**
 این گزینه ترکیبی از `a`، `u` و `x` است و اطلاعات کاملی از پردازه‌های همه کاربران را نمایش می‌دهد.

```sh
ps -aux
```

- `a` → پردازه‌های همه کاربران
- `u` → نمایش پردازه‌ها در فرمت کاربرپسند
- `x` → پردازه‌های بدون ترمینال را نیز نمایش می‌دهد

**`He-`**
 پردازه‌ها را همراه با سلسله‌مراتب (Hierarchy) نمایش می‌دهد.

```sh
ps -He
```

**`axjf-`**
 پردازه‌ها را به‌صورت درختی و همراه با اطلاعات گروه‌های پردازشی نمایش می‌دهد.

```sh
ps -axjf
```

**`u-`**
 اطلاعات پردازه‌های یک کاربر خاص را نمایش می‌دهد.

```sh
ps -u username
```

**`ax-`**
 پردازه‌های همه کاربران را بدون در نظر گرفتن ترمینال نمایش می‌دهد.

```sh
ps -ax
```

#### Command `top`

دستور `top` یکی از ابزارهای مهم برای مانیتورینگ سیستم در لینوکس است که اطلاعات زنده و پویا درباره پردازه‌ها (Processes) و منابع سیستمی (مانند مصرف CPU و RAM) را نمایش می‌دهد. این ابزار به صورت real-time اجرا می‌شود و می‌توان آن را به‌روزرسانی کرد.

وقتی `top` را اجرا می‌کنید، خروجی آن شامل چندین بخش است:

**اطلاعات کلی سیستم (Header Section)**

**uptime**: مدت زمان روشن بودن سیستم

**users**: تعداد کاربران متصل به سیستم

**load average**: میانگین بار پردازشی در ۱، ۵ و ۱۵ دقیقه اخیر

**tasks**: تعداد کل پردازه‌ها (running، sleeping، stopped، zombie)

**CPU usage**: میزان استفاده از پردازنده توسط پردازه‌های مختلف

**Memory usage**: میزان استفاده از RAM و Swap

**لیست پردازه‌ها (Process List)**

`PID`: شناسه پردازه

`USER`: کاربری که پردازه را اجرا کرده است

`%CPU`: درصد استفاده از پردازنده

`%MEM`: درصد استفاده از حافظه

`COMMAND`: نام پردازه

هنگامی که `top` اجرا شده است، می‌توانید از کلیدهای مختلفی برای تعامل با آن استفاده کنید:

**`k` (Kill Process)**
 این کلید برای خاتمه دادن به یک پردازه استفاده می‌شود.
 پس از زدن `k`، از شما خواسته می‌شود که `PID` پردازه‌ای را که می‌خواهید متوقف کنید وارد کنید. سپس می‌توانید یک **سیگنال** مانند `9` (SIGKILL) را وارد کنید.

**مثال:**

```
k
Enter PID to kill: 1234
Send signal [15]: 9
```

 پردازه `1234` فوراً متوقف می‌شود.

------

**`r` (Renice Process Priority)**
 این کلید برای تغییر اولویت (nice value) یک پردازه استفاده می‌شود.
 پس از زدن `r`، از شما خواسته می‌شود `PID` پردازه را وارد کرده و سپس مقدار **nice** را تعیین کنید.

مقادیر **منفی** (مثلاً `-10`) اولویت پردازه را افزایش می‌دهند.

مقادیر **مثبت** (مثلاً `10`) اولویت پردازه را کاهش می‌دهند.

**مثال:**

```
r
PID to renice: 5678
New nice value: -5
```

 پردازه `5678` سریع‌تر اجرا خواهد شد.

------

**`P` (Sort by CPU Usage)**
 پردازه‌ها را بر اساس میزان استفاده از **CPU** مرتب می‌کند (بیشترین مصرف در بالای لیست).

**مثال:**

```
P
```

 پردازه‌هایی که بیشترین مقدار CPU را مصرف می‌کنند، در بالای لیست نمایش داده می‌شوند.

------

**`M` (Sort by Memory Usage)**
 پردازه‌ها را بر اساس میزان استفاده از **حافظه (RAM)** مرتب می‌کند.

**مثال:**

```
M
```

 پردازه‌هایی که بیشترین RAM را مصرف می‌کنند، در بالای لیست قرار می‌گیرند.

------

**`s` (Change Update Interval)**
 فاصله زمانی بین هر **به‌روزرسانی** در `top` را تغییر می‌دهد.
 مقدار پیش‌فرض ۳ ثانیه است، اما می‌توان آن را تغییر داد.

**مثال:**

```
s
Change delay from 3.0 to: 1
```

 اطلاعات هر **۱ ثانیه** به‌روزرسانی می‌شود.

------

**`u` (Filter by User)**
 این کلید پردازه‌های مربوط به یک **کاربر خاص** را فیلتر می‌کند.

**مثال:**

```
u
Show processes for user: root
```

#### Command `free`

## **دستور `free` در لینوکس**

دستور `free` در لینوکس برای نمایش اطلاعات مربوط به میزان حافظه **RAM** و **Swap** در سیستم استفاده می‌شود. این دستور مقدار **کل حافظه**، **حافظه‌ی استفاده‌شده**، **حافظه‌ی در دسترس** و **بافرها/کش‌ها** را نمایش می‌دهد.

اجرای `free` بدون هیچ گزینه‌ای، خروجی‌ای مشابه زیر نمایش می‌دهد:

```sh
free
```

خروجی:

```
              total        used        free      shared  buff/cache   available
Mem:        16000000     6000000     4000000      500000     6000000    10000000
Swap:        8000000      2000000     6000000
```

| ستون           | توضیح                                                      |
| -------------- | ---------------------------------------------------------- |
| **total**      | مقدار کل حافظه‌ی RAM/Swap موجود در سیستم                    |
| **used**       | مقدار حافظه‌ای که توسط پردازه‌ها و سیستم استفاده می‌شود       |
| **free**       | مقدار حافظه‌ی RAM/Swap که هنوز استفاده نشده است             |
| **shared**     | مقدار حافظه‌ای که بین چند پردازه به اشتراک گذاشته شده است   |
| **buff/cache** | مقدار حافظه‌ای که توسط بافرها و کش‌های سیستم نگه‌داری می‌شود   |
| **available**  | مقدار حافظه‌ای که برای استفاده‌ی برنامه‌های جدید در دسترس است |

#### Command `htop`

`htop` یک ابزار پیشرفته و تعاملی برای مانیتورینگ پردازه‌ها در لینوکس است که عملکردی مشابه `top` دارد، اما **با رابط گرافیکی بهتر و قابلیت‌های بیشتر**.

# Shel Script

## شل اسکریپت چیست؟

شل اسکریپت (Shell Script) یک زبان برنامه‌نویسی **مفسری** است که برای اجرای دستورات در محیط خط فرمان (Shell) سیستم‌های یونیکس و لینوکس استفاده می‌شود. این زبان امکان **اتوماتیک‌سازی وظایف** و اجرای مجموعه‌ای از دستورات به صورت متوالی را فراهم می‌کند.

## نحوه شروع یک اسکریپت شل

هر فایل شل اسکریپت باید با **خط شِبانگ (Shebang)** شروع شود تا مفسر موردنظر برای اجرای اسکریپت مشخص شود. خط زیر را در ابتدای فایل قرار می‌دهیم:

```
#!/bin/sh
```

`#!` : این دو کاراکتر نشان می‌دهند که اسکریپت باید توسط یک مفسر خاص اجرا شود.

`/bin/sh` : مسیر مفسر شل (`sh`) که برای اجرای اسکریپت استفاده می‌شود.

در بیشتر سیستم‌های مدرن، `**sh**` **به** `**bash**` **لینک شده است**، بنابراین اجرای `sh` همان `bash` را اجرا می‌کند. اما در برخی توزیع‌ها، `sh` می‌تواند به مفسر دیگری مانند `dash` اشاره کند که ممکن است از برخی قابلیت‌های `bash` پشتیبانی نکند.

## نحوه اجرای یک فایل Bash

برای اجرای یک اسکریپت شل، سه روش مختلف وجود دارد:

**1. اجرای مستقیم پس از دادن مجوز اجرا**

در این روش ابتدا باید به فایل **مجوز اجرایی (Executable Permission)** بدهیم و سپس آن را اجرا کنیم:

```
chmod +x file.sh   # اعطای مجوز اجرا
./file.sh         # اجرای فایل
```

🔹 با اجرای `chmod +x`، فایل `file.sh` به عنوان یک برنامه اجرایی شناخته می‌شود و می‌توان آن را مستقیماً اجرا کرد.

## **2. اجرای اسکریپت با استفاده از** `bash`

در این روش نیازی به تغییر مجوزها نیست و می‌توان فایل را مستقیماً با `bash` اجرا کرد:

```
bash file.sh
```

🔹 در این حالت `bash` اسکریپت را اجرا می‌کند، بدون توجه به اینکه مجوز اجرای مستقیم داشته باشد یا نه.

## **3. اجرای اسکریپت از هر جای سیستم**

اگر فایل اسکریپت را در مسیر `**/usr/local/bin/**` قرار دهیم، می‌توان آن را **بدون نیاز به مسیر کامل یا پسوند** اجرا کرد.

**مراحل انجام این کار:**

فایل اسکریپت را به `/usr/local/bin/` منتقل کنید:

```
sudo mv file.sh /usr/local/bin/
```

به آن مجوز اجرا بدهید:

```
sudo chmod +x /usr/local/bin/file.sh
```

اکنون می‌توان اسکریپت را بدون نیاز به ذکر مسیر یا پسوند اجرا کرد:

```
file.sh
```

🔹 این روش مناسب اسکریپت‌هایی است که می‌خواهید **به‌عنوان یک دستور سیستم** در هر جایی از ترمینال اجرا شوند.

**فرمان‌های داخلی و خارجی در شل اسکریپت**

در شل اسکریپت، دستورات به دو دسته‌ی کلی تقسیم می‌شوند:

**۱. فرمان‌های داخلی (Internal Commands)**

این دسته از فرمان‌ها به‌صورت پیش‌فرض در محیط شل بارگذاری شده‌اند و برای اجرا نیازی به جستجو در مسیر `PATH` ندارند. این دستورات معمولاً از ویژگی‌های اصلی شل محسوب می‌شوند و مستقیماً توسط مفسر شل پردازش می‌شوند. برخی از مهم‌ترین دستورات داخلی عبارت‌اند از:

- **`cd`** (تغییر دایرکتوری)
- **`echo`** (چاپ متن در خروجی)
- **`export`** (تعریف متغیرهای محیطی)
- **`for` ، `if` ، `while`** (دستورات کنترلی و شرطی)
- **`exit`** (خروج از اسکریپت یا ترمینال)

**۲. فرمان‌های خارجی (External Commands)**

این فرمان‌ها به‌صورت پیش‌فرض در محیط شل قرار ندارند و برای اجرا، سیستم آن‌ها را در مسیر `PATH` جستجو می‌کند. این دستورات معمولاً به‌صورت فایل‌های اجرایی مستقل در سیستم‌عامل ذخیره شده‌اند. برخی از دستورات رایج خارجی شامل موارد زیر هستند:

- **`ls`** (لیست کردن محتویات یک دایرکتوری)
- **`grep`** (جستجو در متن)
- **`find`** (جستجوی فایل‌ها در سیستم)
- **`awk`** و **`sed`** (پردازش متن)

------

**اجرای دستورات در پس‌زمینه**

در شل اسکریپت، اگر در انتهای یک دستور علامت **`&`** اضافه شود، آن دستور در **پس‌زمینه** اجرا خواهد شد. این ویژگی برای اجرای هم‌زمان چندین فرآیند بدون متوقف کردن اجرای کل اسکریپت مفید است.

```sh
command &
```

✅ **نکته:** این علامت *به معنای نادیده گرفتن خطا نیست*. اگر می‌خواهید خطاهای یک دستور را نادیده بگیرید و اجرای اسکریپت متوقف نشود، می‌توانید از `command || true` یا `command || :` استفاده کنید.

------

**ارسال آرگومان به یک شل اسکریپت**

در شل اسکریپت، می‌توان آرگومان‌ها را هنگام اجرا به آن ارسال کرد. ساختار کلی این کار به‌صورت زیر است:

```sh
./script.sh ARG1 ARG2 ARG3 ...
```

✅ **نکته:** اگر ابتدای یک آرگومان، **`-`** (خط تیره) قرار گیرد، سیستم آن را به‌عنوان یک *گزینه (Option)* در نظر می‌گیرد، نه یک آرگومان عادی.

------

**دسترسی به آرگومان‌ها درون اسکریپت**

درون اسکریپت، آرگومان‌ها به‌صورت متغیرهایی با نماد `$` قابل‌دسترسی هستند:

- **`$0`** → نام فایل اسکریپت
- **`$1`** → اولین آرگومان
- **`$2`** → دومین آرگومان
- **`$3`** → سومین آرگومان
- **`...`** → سایر آرگومان‌ها

مثال:

```sh
#!/bin/bash
echo "Script Name: $0"
echo "First Argument: $1"
echo "Second Argument: $2"
```

خروجی:

```sh
$ ./script.sh Hello World
Script Name: ./script.sh
First Argument: Hello
Second Argument: World
```

------

**متغیرهای ویژه در شل**

علاوه بر `$0`، `$1` و سایر آرگومان‌ها، شل تعدادی متغیر خاص دارد که اطلاعات مفیدی درباره اجرای اسکریپت ارائه می‌دهند:

| متغیر    | توضیح                                                        |
| -------- | ------------------------------------------------------------ |
| **`$#`** | تعداد کل آرگومان‌های ارسال‌شده به اسکریپت                      |
| **`$*`** | تمام آرگومان‌ها به‌صورت یک رشته‌ی واحد                          |
| **`$@`** | تمام آرگومان‌ها به‌صورت مجموعه‌ای از مقادیر جداگانه             |
| **`$?`** | وضعیت خروجی آخرین دستور اجراشده (۰ برای موفقیت، عددی دیگر در صورت خطا) |
| **`$$`** | شناسه پردازش (PID) اسکریپت جاری                              |
| **`$!`** | شناسه پردازش آخرین دستور پس‌زمینه                             |

------

**تفاوت `$*` و `$@`**

- **`$*`** تمام آرگومان‌ها را به‌عنوان *یک رشته‌ی واحد* برمی‌گرداند.
- **`$@`** تمام آرگومان‌ها را به‌عنوان *یک مجموعه‌ی جداگانه* برمی‌گرداند.

مثال:

```sh
#!/bin/bash
echo "Using $*:"
for arg in "$*"; do
    echo "$arg"
done

echo "Using \$@:"
for arg in "$@"; do
    echo "$arg"
done
```

اجرای اسکریپت:

```sh
$ ./script.sh A B C
```

خروجی:

```
Using $*:
A B C

Using $@:
A
B
C
```

------

**کاربرد `$?` – بررسی وضعیت اجرای دستورات**

متغیر `$?` مقدار *وضعیت خروجی (Exit Status)* آخرین دستور اجراشده را نگه می‌دارد. مقدار **۰** نشان‌دهنده‌ی اجرای موفقیت‌آمیز است، درحالی‌که مقدار غیر از صفر نشان‌دهنده‌ی وقوع خطا است.

مثال:

```sh
#!/bin/bash
ls /home
echo "Exit Status: $?"
ls /invalid/path
echo "Exit Status: $?"
```

خروجی:

```
Exit Status: 0
ls: cannot access '/invalid/path': No such file or directory
Exit Status: 2
```

------

**کاربرد `$$` – دریافت شناسه پردازش (PID) اسکریپت**

متغیر `$$` شناسه‌ی پردازش (Process ID) مربوط به اسکریپت جاری را نمایش می‌دهد.

مثال:

```sh
#!/bin/bash
echo "Current Script PID: $$"
```

خروجی:

```
Current Script PID: 12345
```

(عدد **۱۲۳۴۵** بسته به اجرای واقعی، مقدار متفاوتی خواهد داشت.)

------

**کاربرد `$!` – دریافت شناسه پردازش آخرین دستور پس‌زمینه**

متغیر `$!` شناسه‌ی پردازش آخرین دستوری را که در پس‌زمینه اجرا شده است، ذخیره می‌کند.

مثال:

```sh
#!/bin/bash
sleep 60 &
echo "Background Process PID: $!"
```

خروجی:

```
Background Process PID: 67890
```



## **تعریف متغیر در شل اسکریپت**

در شل اسکریپت، تعریف متغیرها بدون استفاده از نوع داده‌ای خاصی انجام می‌شود. برای مقداردهی به یک متغیر، نباید بین نام متغیر، علامت `=` و مقدار آن، فاصله‌ای قرار بگیرد.

❌ **نادرست:**

```sh
VAR1 = Hi
```

✅ **درست:**

```sh
VAR1="Hi"
echo $VAR1
```

در مثال بالا، مقدار `"Hi"` به متغیر `VAR1` اختصاص داده شده است و مقدار آن با `$VAR1` قابل دسترسی است.

------

## **قرار دادن خروجی یک دستور در متغیر**

برای ذخیره‌ی خروجی یک دستور درون یک متغیر، می‌توان از یکی از دو روش زیر استفاده کرد:

**۱. استفاده از `backticks` (`` ``)**

```sh
x=`ls`
echo "$x"
```

**۲. استفاده از `$(command)`**

```sh
x=$(ls)
echo "$x"
```

✅ روش **`$(command)`** خواناتر و توصیه‌شده‌تر است.

------

## **متغیرهای پیش‌فرض در شل**

در محیط شل، متغیرهای سیستمی از قبل تعریف شده‌اند که اطلاعات مفیدی درباره سیستم، کاربر و محیط ترمینال ارائه می‌دهند.

| متغیر          | توضیح                                 |
| -------------- | ------------------------------------- |
| **`HOSTNAME`** | نام میزبان سیستم                      |
| **`SHELL`**    | مسیر اجرایی شل جاری                   |
| **`HOME`**     | مسیر دایرکتوری خانه‌ی کاربر            |
| **`PATH`**     | مسیرهای جستجو برای اجرای دستورات      |
| **`HISTSIZE`** | تعداد دستورات ذخیره‌شده در تاریخچه‌ی شل |
| **`USER`**     | نام کاربری جاری                       |

مثال:

```sh
echo "Hostname: $HOSTNAME"
echo "Current Shell: $SHELL"
echo "Home Directory: $HOME"
echo "User: $USER"
```

------

**ساختار `if` در شل اسکریپت**

ساختار **`if`** برای اجرای شرطی دستورات استفاده می‌شود.

**۱. ساختار کلی `if`**

```sh
if [ شرط ]; then
    دستوراتی که در صورت برقرار بودن شرط اجرا می‌شوند
fi
```

✅ **`fi`** پایان بلوک `if` را مشخص می‌کند.

**۲. استفاده از `else`**

```sh
if [ شرط ]; then
    دستوراتی که در صورت درست بودن شرط اجرا می‌شوند
else
    دستوراتی که در صورت نادرست بودن شرط اجرا می‌شوند
fi
```

**۳. استفاده از `elif` (چندین شرط)**

```sh
if [ شرط1 ]; then
    دستور در صورت درست بودن شرط1
elif [ شرط2 ]; then
    دستور در صورت درست بودن شرط2
else
    دستور در صورت نادرست بودن همه‌ی شرایط
fi
```

**۴. مثال از `if` در شل**

```sh
#!/bin/bash
read -p "Enter a number: " num

if [ $num -gt 10 ]; then
    echo "The number is greater than 10"
elif [ $num -eq 10 ]; then
    echo "The number is exactly 10"
else
    echo "The number is less than 10"
fi
```

✅ **نکته:** برای مقایسه اعداد، باید از `-eq`، `-ne`، `-gt`، `-lt`، `-ge` و `-le` استفاده کرد.

✅ **نکته:** برای مقایسه رشته‌ها، می‌توان از `=`، `!=` و `-z` (برای بررسی تهی بودن) استفاده کرد.

```sh
if [ "$str" = "hello" ]; then
    echo "Matched"
fi
```

------

**حلقه `for` در شل اسکریپت**

حلقه‌ی **`for`** برای اجرای تکراری دستورات روی یک مجموعه از مقادیر استفاده می‌شود.

**۱. ساختار `for` برای یک لیست مشخص**

```sh
for var in item1 item2 item3; do
    echo "Item: $var"
done
```

🔹 **مثال: چاپ نام رنگ‌ها**

```sh
#!/bin/bash
for color in Red Green Blue; do
    echo "Color: $color"
done
```

خروجی:

```
Color: Red
Color: Green
Color: Blue
```

**۲. اجرای حلقه بر روی فایل‌ها**

```sh
for file in *.txt; do
    echo "Processing $file"
done
```

**۳. استفاده از `for` در یک بازه عددی**

```sh
for i in {1..5}; do
    echo "Number: $i"
done
```

✅ **نکته:** در برخی نسخه‌های شل مانند **sh**، `{1..5}` پشتیبانی نمی‌شود. در این موارد، می‌توان از `seq` استفاده کرد:

```sh
for i in $(seq 1 5); do
    echo "Number: $i"
done
```

------

## **تعریف تابع در شل اسکریپت**

در شل، می‌توان **توابع (Functions)** تعریف کرد تا کد خواناتر شده و قابلیت استفاده مجدد داشته باشد.

**۱. روش اول: تعریف تابع**

```sh
function my_function {
    echo "Hello from function!"
}
```

**۲. روش دوم: تعریف کوتاه‌تر**

```sh
my_function() {
    echo "Hello from function!"
}
```

**۳. نحوه‌ی فراخوانی تابع**

```sh
my_function
```

**۴. ارسال آرگومان به تابع**

می‌توان مقادیر را هنگام فراخوانی به تابع ارسال کرد:

```sh
greet() {
    echo "Hello, $1!"
}

greet "Alice"
greet "Bob"
```

🔹 خروجی:

```
Hello, Alice!
Hello, Bob!
```

**۵. مقدار بازگشتی از تابع**

یک تابع می‌تواند مقدار **exit status** بازگرداند (عدد ۰ برای موفقیت و غیر از ۰ برای خطا):

```sh
check_number() {
    if [ $1 -gt 10 ]; then
        return 0  # موفقیت
    else
        return 1  # خطا
    fi
}

check_number 15
echo "Exit status: $?"  # 0

check_number 5
echo "Exit status: $?"  # 1
```

✅ مقدار **`$?`** نشان‌دهنده‌ی وضعیت خروجی آخرین دستور یا تابع است.

**عملگرهای منطقی `&&` و `||` در شل اسکریپت**

در شل اسکریپت، دو عملگر **`&&`** و **`||`** برای کنترل جریان اجرای دستورات استفاده می‌شوند. این عملگرها مشابه **عملگرهای منطقی در زبان‌های برنامه‌نویسی** عمل می‌کنند و می‌توانند جایگزین `if` شوند.

------

**۱. عملگر `&&` (AND – اجرای شرطی در صورت موفقیت)**

عملگر **`&&`** باعث می‌شود که **دستور دوم تنها در صورتی اجرا شود که دستور اول با موفقیت اجرا شده باشد (exit status = 0).**

🔹 **ساختار کلی:**

```sh
command1 && command2
```

✅ **اگر `command1` موفق باشد (`exit status = 0`)، `command2` اجرا می‌شود. در غیر این صورت، `command2` نادیده گرفته می‌شود.**

🔹 **مثال:**

```sh
mkdir new_folder && echo "Folder created successfully!"
```

✅ **اگر `mkdir new_folder` با موفقیت اجرا شود، `echo` نیز اجرا خواهد شد.**
 ❌ **اگر `mkdir new_folder` خطا دهد (مثلاً پوشه از قبل وجود داشته باشد)، `echo` اجرا نمی‌شود.**

------

**۲. عملگر `||` (OR – اجرای شرطی در صورت شکست دستور قبلی)**

عملگر **`||`** باعث می‌شود که **دستور دوم تنها در صورتی اجرا شود که دستور اول شکست بخورد (`exit status ≠ 0`).**

🔹 **ساختار کلی:**

```sh
command1 || command2
```

✅ **اگر `command1` موفق باشد، `command2` اجرا نخواهد شد.**
 ✅ **اگر `command1` خطا دهد، `command2` اجرا خواهد شد.**

🔹 **مثال:**

```sh
mkdir new_folder || echo "Failed to create folder!"
```

✅ **اگر `mkdir` موفق شود، `echo` اجرا نمی‌شود.**
 ❌ **اگر `mkdir` شکست بخورد، پیام "Failed to create folder!" نمایش داده می‌شود.**

------

**۳. ترکیب `&&` و `||` – جایگزینی برای `if` (ساختار Ternary)**

با ترکیب **`&&`** و **`||`**، می‌توان یک ساختار مشابه **عملگر `?:` (سه‌تایی – ternary) در زبان‌هایی مثل C و PHP** ایجاد کرد.

🔹 **ساختار کلی:**

```sh
command && success_command || failure_command
```

✅ **اگر `command` موفق شود، `success_command` اجرا می‌شود و `failure_command` نادیده گرفته می‌شود.**
 ✅ **اگر `command` شکست بخورد، `failure_command` اجرا می‌شود.**

🔹 **مثال:**

```sh
[ -d /etc ] && echo "Directory exists!" || echo "Directory does not exist!"
```

✅ **اگر دایرکتوری `/etc` وجود داشته باشد، پیام `"Directory exists!"` نمایش داده می‌شود.**
 ❌ **اگر دایرکتوری وجود نداشته باشد، پیام `"Directory does not exist!"` نمایش داده می‌شود.**

🔹 **مثال با بررسی دسترسی به اینترنت:**

```sh
ping -c 1 google.com && echo "Internet is available" || echo "No internet connection"
```

✅ **اگر `ping` موفق شود، پیام `"Internet is available"` نمایش داده می‌شود.**
 ❌ **اگر `ping` شکست بخورد، پیام `"No internet connection"` نمایش داده می‌شود.**

------

**۴. مقایسه `if` با `&&` و `||`**

🔹 **روش `if`:**

```sh
if command; then
    success_command
else
    failure_command
fi
```

🔹 **روش معادل با `&&` و `||`:**

```sh
command && success_command || failure_command
```

✅ **روش `&&` و `||` کوتاه‌تر و خواناتر است، اما برای شرایط پیچیده بهتر است از `if` استفاده شود.**

------

**۵. اجرای چندین دستور به صورت ترکیبی**

می‌توان چندین دستور را با استفاده از این عملگرها ترکیب کرد:

```sh
mkdir test_dir && cd test_dir && touch file.txt || echo "Operation failed"
```

✅ **اگر `mkdir` و `cd` موفق باشند، فایل `file.txt` ایجاد می‌شود.**
 ❌ **اگر هرکدام از این دستورات شکست بخورند، پیام `"Operation failed"` نمایش داده می‌شود.**

**پسوند فایل شل اسکریپت**

در شل اسکریپت‌ها، به طور پیش‌فرض نیاز نیست که فایل‌ها پسوند `.sh` داشته باشند. شل اسکریپت‌ها می‌توانند بدون پسوند نیز اجرا شوند، اما از آنجا که استفاده از پسوند `.sh` برای شل اسکریپت‌ها رایج است، این کار باعث **افزایش خوانایی** و **شناسایی آسان‌تر** اسکریپت‌ها می‌شود. به عنوان مثال:

🔹 **فایل بدون پسوند:**

```sh
./myscript
```

🔹 **فایل با پسوند `.sh`:**

```sh
./myscript.sh
```

این دو فایل عملکرد یکسانی دارند (در صورتی که مجوز اجرای فایل برقرار باشد) و تنها تفاوتشان در نام است.

#### Command `which`

دستور **`which`** برای پیدا کردن آدرس دقیق برنامه‌ای که در حال اجرای آن هستید یا می‌خواهید آن را اجرا کنید، استفاده می‌شود. وقتی از این دستور استفاده می‌کنید، شل به دنبال برنامه‌ای که در دستور وارد کرده‌اید، در مسیرهای تعریف‌شده در **`$PATH`** می‌گردد و اگر آن برنامه پیدا شود، مسیر کامل آن را نمایش می‌دهد.

**ساختار دستور `which`:**

```sh
which command_name
```

**مثال:**

```sh
which ls
```

🔹 این دستور مسیر دقیق اجرایی برنامه `ls` را نمایش می‌دهد (مثلاً `/bin/ls`).

🔹 اگر برنامه‌ای در مسیرهای `$PATH` نباشد، دستور `which` خروجی نمی‌دهد و فقط برمی‌گردد.

🔹 **مثال دیگر:**

```sh
which python3
```

این دستور مسیر دقیق اجرایی برنامه `python3` را نشان می‌دهد (مثل `/usr/bin/python3`).

------

**دستور `read` در شل**

دستور **`read`** در شل اسکریپت برای دریافت ورودی از کاربر استفاده می‌شود. با استفاده از این دستور می‌توان متغیرهایی را از کاربر دریافت کرده و در اسکریپت از آن‌ها استفاده کرد. این ورودی‌ها می‌توانند مقادیر ساده‌ای مانند متن یا اعداد باشند.

**ساختار دستور `read`:**

```sh
read variable_name
```

**جزئیات عملکرد:**

**`variable_name`** نام متغیری است که ورودی در آن ذخیره می‌شود.

این دستور منتظر ورودی کاربر می‌ماند و بعد از اینکه کاربر داده‌ای وارد کرد، دستور بعدی اجرا می‌شود.

**مثال:**

```sh
#!/bin/bash
echo "What is your name?"
read name
echo "Hello, $name!"
```

🔹 **خروجی:**

```
What is your name?
Alice
Hello, Alice!
```

------

**ویژگی‌های اضافی `read`:**

**دریافت ورودی به صورت پیش‌فرض** ورودی‌ای که کاربر وارد می‌کند به صورت پیش‌فرض در متغیرهایی مانند `$name` ذخیره می‌شود. می‌توان برای تعیین نام متغیرها از دستور `read` استفاده کرد.

**استفاده از دستور `-p` برای چاپ پیام قبل از ورودی** اگر می‌خواهید پیامی را قبل از دریافت ورودی چاپ کنید، می‌توانید از گزینه `-p` استفاده کنید:

```sh
read -p "Enter your age: " age
echo "You are $age years old."
```

**دریافت ورودی به صورت چندکلمه‌ای** برای دریافت ورودی که شامل فاصله‌ها باشد، می‌توانید از دستور `IFS` (Internal Field Separator) استفاده کنید تا ورودی چندکلمه‌ای را در یک متغیر ذخیره کنید:

```sh
read -p "Enter your full name: " full_name
echo "Your full name is $full_name."
```

**محدودیت زمان برای ورودی (دستور `-t`)** با استفاده از گزینه `-t` می‌توانید یک محدودیت زمانی برای ورودی کاربر تنظیم کنید:

```sh
read -t 10 -p "Enter your name (you have 10 seconds): " name
echo "Hello, $name!"
```

------

**حلقه `while` در شل**

حلقه **`while`** در شل برای اجرای دستورات به طور مداوم و تا زمانی که یک شرط برقرار باشد، استفاده می‌شود. این حلقه زمانی ادامه می‌یابد که شرط مورد نظر درست باشد.

**ساختار کلی حلقه `while`:**

```sh
while [ شرط ]; do
    دستورات
done
```

🔹 **اگر شرط صحیح باشد، حلقه اجرا می‌شود و اگر نادرست باشد، حلقه خاتمه می‌یابد.**

**مثال:**

```sh
#!/bin/bash
count=1
while [ $count -le 5 ]; do
    echo "Count is $count"
    ((count++))
done
```

🔹 **خروجی:**

```
Count is 1
Count is 2
Count is 3
Count is 4
Count is 5
```

در این مثال، حلقه تا زمانی که متغیر `count` کمتر یا مساوی ۵ باشد، اجرا می‌شود و بعد از هر تکرار، `count` یکی افزایش می‌یابد.

------

**ترکیب حلقه `while` با دستورات دیگر:**

**حلقه برای خواندن از یک فایل:** می‌توان از حلقه `while` برای پردازش محتویات یک فایل خط به خط استفاده کرد:

```sh
while read line; do
    echo "Processing: $line"
done < input.txt
```

**حلقه بی‌نهایت:** اگر بخواهید یک حلقه بی‌نهایت ایجاد کنید که همیشه اجرا شود، می‌توانید از عبارت `true` یا `:` استفاده کنید:

```sh
while :; do
    echo "This will run forever."
    sleep 1
done
```

**استفاده از دستورات با عملگر `&&` و `||`:** می‌توانید دستورات را داخل حلقه `while` ترکیب کنید تا عملکرد بهتری داشته باشید:

```sh
while [ $count -le 5 ]; do
    echo "Count: $count" && ((count++)) || break
done
```

------

**نکات مهم در مورد حلقه `while`:**

حلقه‌های `while` به طور مداوم اجرا می‌شوند تا زمانی که شرط برقرار باشد.

اگر شرایط را به درستی تنظیم نکنید، حلقه ممکن است وارد **حلقه بی‌نهایت** شود.

حلقه‌های `while` زمانی که از یک ورودی استفاده می‌کنند، ممکن است تحت تاثیر ورودی نادرست یا شرایط غیرمنتظره قرار بگیرند.

## **حلقه `until` در شل اسکریپت**

حلقه **`until`** مشابه حلقه **`while`** است، با این تفاوت که **حلقه `until` اجرا می‌شود تا زمانی که شرط نادرست باشد**، در حالی که **حلقه `while` تا زمانی که شرط درست باشد اجرا می‌شود**. به عبارت دیگر، شرط در حلقه `until` برعکس حلقه `while` ارزیابی می‌شود.

------

## **ساختار حلقه `until`**

ساختار کلی حلقه `until` به این شکل است:

```sh
until [ شرط ]; do
    دستورات
done
```

- **شرط**: این شرط باید در قالب یک عبارت منطقی باشد. تا زمانی که این شرط **نادرست** باشد، حلقه ادامه می‌یابد.
- **دستورات**: این دستورات در هر تکرار حلقه اجرا می‌شوند تا زمانی که شرط **درست** شود.

------

## **مثال ساده از حلقه `until`**

```sh
#!/bin/bash
count=1
until [ $count -gt 5 ]; do
    echo "Count is $count"
    ((count++))
done
```

**توضیحات:**

- حلقه `until` تا زمانی که شرط `[ $count -gt 5 ]` نادرست باشد اجرا می‌شود.
- هر بار که `count` به ۵ می‌رسد، شرط درست می‌شود و حلقه متوقف می‌شود.
- در نتیجه، تا زمانی که `count` برابر با یا کمتر از ۵ باشد، حلقه ادامه می‌یابد و پس از آن متوقف می‌شود.

**خروجی:**

```
Count is 1
Count is 2
Count is 3
Count is 4
Count is 5
```

------

## **تفاوت حلقه `until` با `while`**

| ویژگی          | حلقه `while`                                | حلقه `until`                                  |
| -------------- | ------------------------------------------- | --------------------------------------------- |
| **شرط**        | تا زمانی که شرط درست باشد، حلقه اجرا می‌شود. | تا زمانی که شرط نادرست باشد، حلقه اجرا می‌شود. |
| **پایان حلقه** | وقتی شرط درست شود، حلقه متوقف می‌شود.        | وقتی شرط درست شود، حلقه متوقف می‌شود.          |
| **ساختار**     | `while [ شرط ]; do ... done`                | `until [ شرط ]; do ... done`                  |

🔹 **حلقه `while`** در صورتی که شرط اولیه درست باشد، اجرا می‌شود، اما در **حلقه `until`**، شرط باید نادرست باشد تا حلقه اجرا شود.

------

## **مثال دیگر از حلقه `until`**

**استفاده از ورودی از کاربر**

```sh
#!/bin/bash
response=""
until [ "$response" == "yes" ]; do
    echo "Do you want to continue? (yes/no)"
    read response
done
echo "You chose to continue!"
```

**توضیحات:**

- در این مثال، حلقه `until` از کاربر می‌خواهد تا زمانی که پاسخ "yes" را وارد کند، پیوسته از او سوال بپرسد.
- حلقه ادامه خواهد داشت تا زمانی که `response` برابر با "yes" شود.

**خروجی ممکن:**

```
Do you want to continue? (yes/no)
no
Do you want to continue? (yes/no)
no
Do you want to continue? (yes/no)
yes
You chose to continue!
```

------

## **حلقه `until` و استفاده از شمارنده**

حلقه `until` می‌تواند برای شمارش به سمت یک عدد خاص نیز استفاده شود، مشابه حلقه‌های `for` یا `while`.

**مثال شمارش معکوس:**

```sh
#!/bin/bash
count=10
until [ $count -lt 1 ]; do
    echo "Countdown: $count"
    ((count--))
done
```

**توضیحات:**

- در این مثال، شمارش از ۱۰ شروع می‌شود و هر بار کاهش می‌یابد تا زمانی که کمتر از ۱ شود، و پس از آن حلقه متوقف می‌شود.
- حلقه ادامه می‌یابد تا زمانی که `count` کمتر از ۱ شود.

**خروجی:**

```
Countdown: 10
Countdown: 9
Countdown: 8
...
Countdown: 1
```

------

## **استفاده از دستور `break` و `continue` در حلقه `until`**

- **دستور `break`** می‌تواند برای خروج از حلقه به طور ناگهانی استفاده شود.
- **دستور `continue`** می‌تواند برای عبور از یک تکرار حلقه و ادامه حلقه از تکرار بعدی استفاده شود.

**مثال با `break` و `continue`:**

```sh
#!/bin/bash
count=1
until [ $count -gt 5 ]; do
    if [ $count -eq 3 ]; then
        echo "Skipping count 3"
        ((count++))
        continue
    fi
    echo "Count is $count"
    ((count++))
done
```

**توضیحات:**

اگر `count` برابر با ۳ شود، حلقه از آن تکرار عبور می‌کند و به تکرار بعدی می‌رود.

`continue` باعث می‌شود که دستورات بعدی در این تکرار اجرا نشوند و تکرار بعدی انجام شود.

**خروجی:**

```
Count is 1
Count is 2
Skipping count 3
Count is 4
Count is 5
```

# Linux Security

در سیستم‌عامل لینوکس، انواع مختلفی از اکانت‌ها وجود دارند که برای اهداف مختلف استفاده می‌شوند. این اکانت‌ها معمولاً به سه دسته اصلی تقسیم می‌شوند:

------

## **۱. اکانت‌های سیستمی (System Accounts)**

این اکانت‌ها معمولاً برای **سرویس‌ها و فرایندهای سیستم** ایجاد می‌شوند و دسترسی‌های خاصی دارند که معمولاً به منظور اجرای برنامه‌ها یا سرویس‌های خاص بر روی سیستم مورد استفاده قرار می‌گیرند. این اکانت‌ها عمدتاً نیازی به ورود کاربر ندارند و به طور خودکار توسط سیستم برای راه‌اندازی و مدیریت سرویس‌ها استفاده می‌شوند.

**ویژگی‌ها:**

این اکانت‌ها برای **اجرای سرویس‌ها** (مثل `mysql` برای دیتابیس، `apache` برای وب سرور و غیره) ایجاد می‌شوند.

معمولاً **دسترسی محدودی** دارند و فقط به منابعی که برای اجرای سرویس خود نیاز دارند دسترسی دارند.

از این اکانت‌ها برای **افزایش امنیت** استفاده می‌شود تا برنامه‌ها نتوانند به سایر قسمت‌های سیستم دسترسی پیدا کنند.

**مثال‌ها:**

`mysql`: برای سرویس دیتابیس MySQL.

`apache`: برای سرویس وب سرور Apache.

`sshd`: برای سرویس SSH.

------

## **۲. اکانت‌های استاندارد (Standard User Accounts)**

این نوع اکانت‌ها برای **کاربران عادی** طراحی شده‌اند که نیاز به دسترسی به سیستم دارند، اما دسترسی‌های محدودی دارند. این کاربران معمولاً می‌توانند به برخی از فایل‌ها و منابع سیستم دسترسی داشته باشند، اما از انجام برخی فعالیت‌ها که ممکن است امنیت سیستم را به خطر بیندازند، منع شده‌اند.

**ویژگی‌ها:**

دسترسی‌های **محدود** دارند و تنها به **برخی دایرکتوری‌ها** و **برنامه‌ها** دسترسی دارند.

نمی‌توانند به بخش‌های حساس سیستم (مثل فایل‌های سیستمی یا تنظیمات خاص) دسترسی داشته باشند.

برای انجام فعالیت‌های روزمره، مانند مرور اینترنت، استفاده از نرم‌افزارهای کاربردی، و دسترسی به فایل‌های شخصی، مورد استفاده قرار می‌گیرند.

**مثال‌ها:**

اکانت‌های کاربران عادی که پس از ورود به سیستم با استفاده از نام کاربری و رمز عبور معمولی، دسترسی‌های خود را دریافت می‌کنند.

کاربرانی که تنها می‌توانند به دایرکتوری خانه (home directory) خود و برخی منابع دیگر دسترسی داشته باشند.

------

## **۳. اکانت‌های ادمین (Administrator Accounts)**

این اکانت‌ها برای **مدیریت سیستم** و انجام عملیات حساس و مدیریتی در سیستم طراحی شده‌اند. اکانت‌های ادمین یا **سرویس‌های ریشه‌ای**، که بیشتر به نام اکانت **root** شناخته می‌شوند، دسترسی کامل به تمامی قسمت‌های سیستم دارند. این کاربران می‌توانند هر تغییری در سیستم ایجاد کنند، از نصب برنامه‌ها گرفته تا مدیریت تنظیمات سیستمی و پیکربندی‌های امنیتی.

**ویژگی‌ها:**

دسترسی **نامحدود** به تمام فایل‌ها، تنظیمات سیستم، و منابع دیگر سیستم دارند.

قادر به انجام تمام **فرایندهای مدیریتی** مانند نصب و حذف بسته‌ها، تغییرات در تنظیمات سیستم، و ایجاد یا حذف اکانت‌های دیگر هستند.

این اکانت‌ها باید بسیار **مراقبت شوند** زیرا در صورت سوءاستفاده یا حمله، ممکن است به تمامی داده‌ها و منابع سیستم دسترسی پیدا کنند.

**مثال‌ها:**

**root**: اکانت پیش‌فرض ادمین سیستم که دسترسی کامل به تمامی فایل‌ها و دستورات سیستم را دارد.

**sudo**: در بسیاری از توزیع‌های لینوکس، کاربران می‌توانند با استفاده از دستور `sudo` به طور موقت دسترسی‌های مدیریتی داشته باشند. این روش به کاربران اجازه می‌دهد که برخی از دستورات را به عنوان اکانت `root` اجرا کنند، بدون اینکه خودشان به طور کامل اکانت ریشه داشته باشند.

#### /etec/passwd

فایل **`/etc/passwd`** در سیستم‌عامل‌های یونیکس و لینوکس، فایلی متنی است که اطلاعات مربوط به اکانت‌های کاربری را در سیستم ذخیره می‌کند. این فایل معمولاً برای مدیریت اطلاعات مربوط به کاربران و نحوه ورود آن‌ها به سیستم استفاده می‌شود.

هر خط در این فایل نمایانگر یک **اکانت کاربری** است و شامل چندین فیلد است که با **دوتا (:)** از یکدیگر جدا می‌شوند.

**ساختار خط در `/etc/passwd`**

یک خط در `/etc/passwd` معمولاً به شکل زیر است:

```
username:password:UID:GID:GECOS:home_directory:shell
```

**توضیحات هر فیلد**

**`username` (نام کاربری)**
 این فیلد نشان‌دهنده نام کاربری یا **login name** است. این نام به کاربر اختصاص دارد و برای ورود به سیستم یا احراز هویت استفاده می‌شود.

**مثال**: `root`, `john`, `alice`

**`password` (رمز عبور)**
 در گذشته، این فیلد شامل **رمز عبور رمزگذاری‌شده** کاربر بود، اما امروزه به طور معمول فقط یک **علامت `x`** در این قسمت قرار دارد. رمز عبور به طور امن‌تر در فایل دیگری به نام **`/etc/shadow`** ذخیره می‌شود که فقط دسترسی به آن برای اکانت‌های ریشه (root) یا مدیران سیستم مجاز است.

**مثال**: `x` یا یک مقدار رمزگذاری‌شده (در نسخه‌های قدیمی‌تر)

**`UID` (شناسه کاربری)**
 این فیلد حاوی شناسه منحصر به فرد **User ID** برای هر کاربر است. این شناسه یک عدد است که به سیستم کمک می‌کند تا تفاوت بین کاربران را تشخیص دهد. برای کاربران عادی، این شناسه معمولاً از ۱۰۰۰ شروع می‌شود (در توزیع‌های مختلف ممکن است متفاوت باشد).

**مثال**: `1000` برای کاربران معمولی یا `0` برای کاربر ریشه (root).

**`GID` (شناسه گروه)**
 این فیلد شامل **Group ID** است که به گروه اصلی کاربر اختصاص دارد. گروه‌ها برای مدیریت دسترسی به فایل‌ها و منابع سیستم استفاده می‌شوند. این شناسه به کاربر گروهی را نسبت می‌دهد که در آن گروه عضو است.

**مثال**: `1000` که نمایانگر گروهی است که کاربر به آن تعلق دارد.

**`GECOS` (اطلاعات تکمیلی)**
 این فیلد معمولاً برای ذخیره اطلاعات تکمیلی کاربر مانند نام کامل، شماره تلفن، آدرس، یا سایر اطلاعات مفید به کار می‌رود. گاهی اوقات این فیلد به عنوان **comment** نیز شناخته می‌شود.

**مثال**: `John Doe,123-456-7890,Development`

توجه کنید که این فیلد معمولاً به صورت دلخواه پر می‌شود و ممکن است خالی باشد.

**`home_directory` (دایرکتوری خانگی)**
 این فیلد مسیر دایرکتوری خانگی کاربر را نشان می‌دهد. دایرکتوری خانگی مکانی است که کاربر می‌تواند فایل‌های خود را ذخیره کند و معمولاً در آن قرار دارد.

**مثال**: `/home/john` یا `/root` برای کاربر ریشه.

**`shell` (شل)**
 این فیلد نوع **شل** (Shell) را که به طور پیش‌فرض برای ورود به سیستم استفاده می‌شود مشخص می‌کند. شل محیطی است که کاربر از آن برای اجرای دستورات استفاده می‌کند. معمولاً شل‌ها به صورت **Bash** (برای اکثر کاربران لینوکس) یا **Zsh** و **Tcsh** هستند. برای کاربران معمولی، ممکن است مسیر `/bin/bash` یا `/bin/zsh` باشد. اگر کاربر قادر به ورود به سیستم نباشد (مثلاً فقط برای اجرای سرویس‌ها)، این فیلد ممکن است به `/usr/sbin/nologin` یا `/bin/false` تنظیم شود.

**مثال**: `/bin/bash`, `/bin/zsh`, `/usr/sbin/nologin`

------

**مثال از فایل `/etc/passwd`**

در زیر یک نمونه از یک خط در فایل `/etc/passwd` آورده شده است:

```
john:x:1000:1000:John Doe:/home/john:/bin/bash
```

این خط نشان می‌دهد که:

**`john`** نام کاربری است.

**`x`** نشان‌دهنده این است که رمز عبور در فایل `/etc/shadow` ذخیره شده است.

**`1000`** شناسه کاربری (UID) است.

**`1000`** شناسه گروه (GID) است.

**`John Doe`** اطلاعات تکمیلی کاربر است.

**`/home/john`** دایرکتوری خانگی کاربر است.

**`/bin/bash`** شل پیش‌فرض کاربر است.

------

**نکات مهم**

**فایل `/etc/passwd` باید همیشه قابل خواندن برای همه کاربران باشد**, زیرا سیستم نیاز دارد که این اطلاعات را برای شناسایی کاربران بخواند.

**دسترسی به `/etc/passwd محدود به خواندن است** (برای اکثر کاربران)، اما تغییر آن تنها به مدیر سیستم یا کاربر ریشه (root) مجاز است.

در فایل **`/etc/passwd`** هیچ اطلاعات رمز عبوری ذخیره نمی‌شود. این اطلاعات در فایل **`/etc/shadow`** به صورت رمزگذاری شده ذخیره می‌شود.

## **UID ** در لینوکس

در سیستم‌عامل لینوکس، **UID** یا **User Identifier** یک شناسه عددی منحصر به فرد است که به هر کاربر در سیستم اختصاص داده می‌شود. این شناسه برای شناسایی کاربر در سطح سیستم و فایل‌ها استفاده می‌شود. در حقیقت، سیستم‌عامل برای مدیریت کاربران و گروه‌ها از **UID** استفاده می‌کند تا تفاوت میان کاربران مختلف را در نظر بگیرد.

**ساختار و نحوه تخصیص UID**

**UID برای کاربرهای معمولی:**

برای هر کاربر در سیستم، یک UID منحصر به فرد در نظر گرفته می‌شود که به هنگام ایجاد حساب کاربری به او اختصاص داده می‌شود.

به طور پیش‌فرض، در اکثر توزیع‌های لینوکس، **UID برای کاربرهای عادی از 1000 شروع می‌شود**. به عنوان مثال، اولین کاربری که به سیستم اضافه می‌شود، به طور معمول UID 1000 خواهد داشت.

**UID برای کاربران سیستم:**

**کاربران سیستم** (مانند کاربرهایی که برای اجرای سرویس‌ها یا برنامه‌های خاص به سیستم اضافه می‌شوند) معمولاً دارای UIDهای **کمتر از 1000** هستند.

این کاربران معمولاً برای اجرای سرویس‌ها و برنامه‌های خاص سیستم ایجاد می‌شوند و نیازی به دسترسی مستقیم کاربری ندارند.

برای مثال، **کاربر `root`** که دسترسی ریشه به سیستم دارد، **UID برابر با 0** دارد.

همچنین، سرویس‌هایی مانند `mysql`, `apache`, `sshd` هر کدام دارای UID خاص خود هستند.

**محدوده UID:**

**UIDهای کوچک‌تر از 1000** معمولاً برای **کاربران سیستمی** استفاده می‌شوند که برای اجرای سرویس‌ها و فرایندهای سیستم به کار می‌روند.

**UIDهای بزرگتر از 1000** به طور معمول برای **کاربران معمولی** اختصاص داده می‌شود که می‌توانند به سیستم وارد شوند و فعالیت‌های روزانه را انجام دهند.

**مفهوم و کاربردهای UID**

**شناسایی کاربران:**

UID یک شناسه منحصر به فرد برای هر کاربر است و سیستم‌عامل با استفاده از UID، کاربران را شناسایی می‌کند. حتی اگر چند کاربر دارای نام‌های مشابه باشند، **UID آنها متفاوت است** و به همین دلیل هر کدام به صورت جداگانه شناسایی می‌شوند.

**مدیریت دسترسی‌ها:**

UID به سیستم این امکان را می‌دهد که دسترسی‌ها را مدیریت کند. برای مثال، زمانی که یک کاربر فایلی را ایجاد می‌کند، فایل به این UID تعلق می‌گیرد و سیستم می‌تواند مشخص کند که کدام کاربر به فایل‌ها دسترسی دارد و چه سطحی از دسترسی برای هر کاربر وجود دارد.

**مدیریت گروه‌ها:**

علاوه بر UID، سیستم لینوکس برای هر کاربر یک یا چند گروه اختصاصی تعیین می‌کند. **GID (Group Identifier)** برای شناسایی گروه‌های کاربری استفاده می‌شود. در نتیجه، این دو شناسه (UID و GID) به سیستم این امکان را می‌دهند که سیاست‌های دسترسی دقیق‌تری را برای منابع مختلف اعمال کند.

**مدیریت فایل‌ها و مالکیت:**

**مالکیت فایل‌ها** در لینوکس با استفاده از UID تعیین می‌شود. هنگامی که یک فایل ایجاد می‌شود، UID کاربر به عنوان مالک فایل در نظر گرفته می‌شود. این به سیستم کمک می‌کند تا تعیین کند کدام کاربران می‌توانند به فایل‌ها دسترسی داشته باشند.

**ورود به سیستم:**

در فرایند ورود به سیستم، سیستم به UID کاربران توجه می‌کند تا تعیین کند که دسترسی‌های خاص برای هر کاربر چه خواهد بود و چطور باید به سیستم وارد شوند.

**مثال‌هایی از UID:**

در فایل **`/etc/passwd`**، هر خط نمایانگر یک کاربر است و شامل اطلاعاتی مانند UID و GID است.

مثال از `/etc/passwd`:

```
john:x:1000:1000:John Doe:/home/john:/bin/bash
root:x:0:0:root:/root:/bin/bash
```

در این مثال:

**کاربر `john`** دارای UID 1000 است.

**کاربر `root`** دارای UID 0 است.

**کاربرد UID در دستورات لینوکس**

**دستور `id`**: با استفاده از دستور `id` می‌توانیم اطلاعات مربوط به UID و GID کاربر را مشاهده کنیم.

```bash
id john
```

خروجی ممکن است چیزی شبیه به این باشد:

```
uid=1000(john) gid=1000(john) groups=1000(john)
```

این به این معنی است که `john` دارای UID 1000 و GID 1000 است.

**دستور `ls` برای مشاهده مالکیت فایل:** می‌توان با استفاده از دستور `ls -l` مالکیت فایل‌ها را مشاهده کرد.

```bash
ls -l /home/john
```

خروجی می‌تواند چیزی شبیه به این باشد:

```
drwxr-xr-x 2 john john 4096 Feb  9 12:00 Documents
```

این نشان می‌دهد که دایرکتوری `Documents` متعلق به کاربر `john` است که UID 1000 دارد.

**دستور `chown` برای تغییر مالکیت:** با استفاده از دستور `chown` می‌توان مالکیت فایل را به یک UID خاص تغییر داد.

```bash
sudo chown 1000:1000 somefile.txt
```

این دستور مالکیت فایل `somefile.txt` را به کاربر و گروه با UID و GID 1000 تغییر می‌دهد.

------

**UID در مقابل GID**

در سیستم‌عامل‌های لینوکس، علاوه بر UID، **GID (Group ID)** نیز برای شناسایی گروه‌ها استفاده می‌شود. در حقیقت، یک کاربر می‌تواند به چندین گروه تعلق داشته باشد، اما هر کاربر تنها یک UID منحصر به فرد دارد.

**UID** به کاربر اختصاص دارد.

**GID** به گروه اختصاص دارد.

#### /etec/shadow

فایل **`/etc/shadow`** در سیستم‌عامل‌های لینوکس، فایلی است که حاوی اطلاعات مربوط به **رمز عبور رمزگذاری‌شده** کاربران و برخی اطلاعات اضافی مربوط به سیاست‌های امنیتی و اعتبارسنجی حساب‌ها است. این فایل به طور خاص برای ذخیره اطلاعات مربوط به رمزهای عبور کاربر، تاریخ تغییرات رمز عبور، و سیاست‌های مربوط به انقضای رمز عبور و دیگر اطلاعات امنیتی استفاده می‌شود.

در مقایسه با فایل **`/etc/passwd`** که اطلاعات عمومی مانند نام کاربری، UID، و GID را ذخیره می‌کند، فایل **`/etc/shadow`** به دلیل حساسیت اطلاعاتی که دارد (یعنی رمزهای عبور) فقط باید توسط **مدیر سیستم (root)** یا فرآیندهایی که به مجوزهای مدیریتی دسترسی دارند، قابل خواندن و نوشتن باشد.

**ساختار فایل `/etc/shadow`**

فایل `/etc/shadow` شامل خط‌هایی است که هرکدام مربوط به یک کاربر در سیستم هستند. هر خط در این فایل شامل **هفت فیلد** است که با **دوتا (:)** از هم جدا شده‌اند.

ساختار کلی هر خط در فایل `/etc/shadow` به شکل زیر است:

```
username:password:lastchg:min:max:warn:inactive:expire
```

**توضیحات هر فیلد**

**`username` (نام کاربری)**
 این فیلد همان نام کاربری است که در فایل `/etc/passwd` وجود دارد. این نام برای شناسایی کاربر در سیستم به کار می‌رود.

**مثال**: `john`, `root`, `alice`

**`password` (رمز عبور رمزگذاری‌شده)**
 این فیلد شامل رمز عبور رمزگذاری‌شده کاربر است. معمولاً این رمز عبور با استفاده از الگوریتم‌های رمزنگاری مانند **SHA-512** یا **bcrypt** ذخیره می‌شود. اگر در این فیلد **`x`** یا **`\*`** وجود داشته باشد، به این معنی است که کاربر قادر به ورود به سیستم نیست (مثلاً در مواردی که دسترسی به سیستم غیرمجاز یا غیرفعال است).

**مثال**: `$6$abcd...$8D5hTgV9H3....`

در صورتی که رمز عبور در این فیلد نباشد، سیستم به طور پیش‌فرض از فایل **`/etc/passwd`** استفاده می‌کند.

**`lastchg` (تاریخ آخرین تغییر رمز عبور)**
 این فیلد نشان‌دهنده **تعداد روزهایی** است که از تاریخ ۱ ژانویه ۱۹۷۰ (epoch) گذشته و آخرین بار که رمز عبور کاربر تغییر کرده است. این عدد به سیستم کمک می‌کند که زمان تغییرات رمز عبور را پیگیری کند و همچنین می‌تواند در سیاست‌های انقضای رمز عبور کاربرد داشته باشد.

**مثال**: `18956` که به معنی تغییر رمز عبور در ۱۸۹۵۶ روز بعد از ۱ ژانویه ۱۹۷۰ است.

**`min` (حداقل تعداد روزها بین تغییرات رمز عبور)**
 این فیلد نشان می‌دهد که حداقل تعداد روزهایی که باید بین دو تغییر رمز عبور برای یک کاربر فاصله باشد، چقدر است. این مقدار معمولاً به صفر تنظیم می‌شود، اما اگر بخواهید از تغییر مکرر رمز عبور جلوگیری کنید، می‌توانید این مقدار را بیشتر از صفر تنظیم کنید.

**مثال**: `7` یعنی حداقل ۷ روز پس از تغییر رمز عبور قبلی، می‌توان رمز عبور جدیدی را تنظیم کرد.

**`max` (حداکثر تعداد روزها تا انقضای رمز عبور)**
 این فیلد نشان‌دهنده حداکثر تعداد روزهایی است که رمز عبور می‌تواند معتبر باشد. بعد از این مدت، رمز عبور منقضی می‌شود و کاربر مجبور به تغییر آن خواهد شد.

**مثال**: `90` یعنی پس از ۹۰ روز از آخرین تغییر رمز عبور، رمز عبور منقضی می‌شود و کاربر باید آن را تغییر دهد.

**`warn` (تعداد روزهای هشدار قبل از انقضا)**
 این فیلد نشان می‌دهد که چند روز قبل از انقضای رمز عبور، سیستم باید به کاربر هشدار دهد که رمز عبور خود را تغییر کند. این هشدار به کاربر اعلام می‌کند که رمز عبور به زودی منقضی خواهد شد.

**مثال**: `7` یعنی سیستم ۷ روز قبل از انقضای رمز عبور به کاربر هشدار می‌دهد.

**`inactive` (تعداد روزهای غیرفعال بودن حساب کاربری)**
 این فیلد نشان‌دهنده تعداد روزهایی است که پس از انقضای رمز عبور، حساب کاربری غیرفعال می‌شود و کاربر دیگر نمی‌تواند به سیستم وارد شود. پس از این مدت، حساب کاربری به طور کامل غیرفعال می‌شود.

**مثال**: `30` یعنی اگر پس از ۳۰ روز کاربر رمز عبور خود را تغییر ندهد، حساب کاربری او غیرفعال خواهد شد.

**`expire` (تاریخ انقضای حساب کاربری)**
 این فیلد نشان‌دهنده تاریخ انقضای حساب کاربری است. این تاریخ به صورت تعداد روزهایی از ۱ ژانویه ۱۹۷۰ (epoch) محاسبه می‌شود. پس از این تاریخ، کاربر دیگر نمی‌تواند به سیستم وارد شود.

**مثال**: `19000` یعنی تاریخ انقضای حساب کاربری ۱۹۰۰۰ روز پس از ۱ ژانویه ۱۹۷۰ است.

------

**مثال از فایل `/etc/shadow`**

```
john:$6$abcd...$8D5hTgV9H3....:18956:7:90:7:30:19000
root:$6$zXkP....$3pGsf98LsS....:18955:0:99999:7:::
```

در این مثال:

**کاربر `john`** دارای رمز عبور رمزگذاری‌شده است که باید تغییر کند. این کاربر به مدت ۹۰ روز اجازه دارد که از رمز عبور فعلی استفاده کند و بعد از آن رمز عبور منقضی می‌شود.

**کاربر `root`** دارای رمز عبور رمزگذاری‌شده است و هیچ محدودیتی در تغییر رمز عبور ندارد. علاوه بر این، این کاربر به هیچ محدودیتی در انقضای حساب یا رمز عبور نیاز ندارد.

------

**ویژگی‌های امنیتی فایل `/etc/shadow`**

**دسترسی محدود**:

فایل `/etc/shadow` باید فقط برای مدیر سیستم (root) قابل خواندن و نوشتن باشد. این فایل حاوی اطلاعات حساس مانند رمز عبور رمزگذاری‌شده است و بنابراین باید از دسترسی غیرمجاز محافظت شود.

**رمزنگاری رمز عبور**:

رمز عبورهای ذخیره‌شده در `/etc/shadow` به صورت **رمزگذاری‌شده** هستند. این رمزگذاری از الگوریتم‌هایی مانند **SHA-512** برای امنیت بیشتر استفاده می‌کند.

**سیاست‌های امنیتی**:

با استفاده از این فایل، می‌توان سیاست‌های امنیتی مربوط به مدت زمان تغییر رمز عبور، مدت زمان هشدار قبل از انقضا، و انقضای حساب‌های کاربری را پیاده‌سازی کرد. این اقدامات به حفظ امنیت و کاهش خطر دسترسی غیرمجاز کمک می‌کنند.

## GID در لینوکس

در لینوکس، **گروه‌ها** برای مدیریت دسترسی‌ها و اجازه دادن به کاربران برای اشتراک منابع استفاده می‌شوند. هر کاربر می‌تواند عضو یک یا چند گروه باشد، و گروه‌ها برای سازماندهی و تنظیم مجوزها به کار می‌روند تا دسترسی به فایل‌ها و دایرکتوری‌ها راحت‌تر مدیریت شود.

گروه‌ها در سیستم لینوکس دو نوع اصلی دارند:

1. **گروه اصلی (Primary Group):**

- هر کاربری که در لینوکس ایجاد می‌شود، به طور خودکار به یک **گروه اصلی** نسبت داده می‌شود. این گروه معمولاً **با نام کاربر یکسان است**.
- **گروه اصلی** بلافاصله پس از ایجاد کاربر، به نام کاربر ساخته می‌شود و به عنوان گروه پیش‌فرض کاربر شناخته می‌شود. این گروه به کاربر اجازه می‌دهد که دسترسی‌های لازم به فایل‌هایی که مالک آن‌ها است، داشته باشد.
- **هدف اصلی** گروه اصلی این است که به کاربر دسترسی به فایل‌های خودش را فراهم کند. در واقع، این گروه مشخص می‌کند که کدام گروه می‌تواند دسترسی به فایل‌های کاربر را به طور پیش‌فرض داشته باشد.
- به طور معمول، گروه اصلی کاربر **تنها گروهی است که کاربر به آن تعلق دارد** و اگر فایل‌ها و دایرکتوری‌ها به این گروه تعلق داشته باشند، کاربر به راحتی می‌تواند از آن‌ها استفاده کند.

**مثال**:
 زمانی که کاربری به نام `john` ایجاد می‌شود، گروه اصلی او به نام `john` نیز به طور خودکار ایجاد می‌شود و همه فایل‌هایی که کاربر `john` ایجاد می‌کند، به طور پیش‌فرض به گروه `john` تعلق خواهند داشت.

2. **گروه‌های فرعی (Secondary Group):**

- علاوه بر گروه اصلی، کاربران می‌توانند به **گروه‌های فرعی** نیز اضافه شوند. این گروه‌ها به کاربر اجازه می‌دهند که به منابع و فایل‌هایی که توسط دیگر گروه‌ها مدیریت می‌شوند، دسترسی داشته باشد.
- هر کاربری می‌تواند به چندین گروه فرعی اضافه شود و این موضوع باعث می‌شود که کاربران به منابع مختلف سیستم دسترسی پیدا کنند. برای مثال، کاربر ممکن است به گروه `developers` اضافه شود تا به منابع مربوط به توسعه دسترسی پیدا کند.
- گروه‌های فرعی برای تخصیص دسترسی‌های خاص به منابع خاص استفاده می‌شوند و به کاربر این امکان را می‌دهند که از منابع مختلف سیستم استفاده کند.

**مثال**:
 فرض کنید که کاربری به نام `alice` دارید. این کاربر ممکن است علاوه بر گروه اصلی خود، که مثلاً `alice` است، به گروه‌های فرعی مانند `admins` و `developers` نیز اضافه شده باشد. به این ترتیب، `alice` می‌تواند به منابعی که برای گروه‌های `admins` و `developers` اختصاص داده شده، دسترسی داشته باشد.

------

**اطلاعات گروه‌ها در لینوکس**

اطلاعات مربوط به گروه‌ها در فایل **`/etc/group`** ذخیره می‌شود. این فایل شامل اطلاعاتی در مورد هر گروه، از جمله نام گروه، GID (شناسه گروه)، و لیست اعضای گروه است. هر خط در این فایل به گروهی اختصاص دارد و ساختار آن به شکل زیر است:

```
group_name:password:GID:user_list
```

توضیح هر بخش:

**`group_name`**: نام گروه.

**`password`**: رمز عبور گروه (که معمولاً خالی یا `x` است).

**`GID`**: شناسه عددی گروه.

**`user_list`**: لیست کاربران عضو این گروه، که نام کاربران با کاما از هم جدا شده‌اند.

**مثال**:

```
john:x:1000:john
developers:x:1001:alice,bob
admins:x:1002:alice,charlie
```

در این مثال:

**گروه `john`** شامل فقط کاربر `john` است.

**گروه `developers`** شامل کاربران `alice` و `bob` است.

**گروه `admins`** شامل کاربران `alice` و `charlie` است.

**GID**

در سیستم‌عامل‌های لینوکس و یونیکس، **GID** یا **Group Identifier** یک شناسه عددی منحصر به فرد است که به هر **گروه کاربری** (group) اختصاص داده می‌شود. مانند **UID** که برای شناسایی کاربران استفاده می‌شود، **GID** نیز برای شناسایی گروه‌ها در سیستم به کار می‌رود.

گروه‌ها در لینوکس به مجموعه‌ای از کاربران گفته می‌شوند که می‌توانند دسترسی به منابع مشترک را داشته باشند. با استفاده از GID، سیستم به راحتی می‌تواند تفاوت میان گروه‌ها را تشخیص داده و کنترل دسترسی به منابع سیستم را مدیریت کند.

**ساختار و نحوه تخصیص GID**

**گروه‌های سیستمی:**

گروه‌هایی که به طور پیش‌فرض توسط سیستم یا سرویس‌ها ایجاد می‌شوند، دارای GIDهای **کمتر از 1000** هستند.

این گروه‌ها معمولاً برای مدیریت دسترسی به منابع خاص سیستم (مانند فایل‌های لاگ یا تنظیمات سرویس‌ها) ایجاد می‌شوند.

برای مثال، گروه‌هایی مانند **`root`**, **`bin`**, **`sys`**, **`mysql`** از GIDهای کمتر از 1000 استفاده می‌کنند.

**گروه‌های کاربری:**

گروه‌هایی که برای کاربران معمولی ایجاد می‌شوند معمولاً GIDهای **بیشتر از 1000** دارند.

هر کاربر در سیستم می‌تواند یک یا چند گروه داشته باشد و به هر گروه GID خاصی نسبت داده می‌شود.

معمولاً در هنگام ایجاد یک کاربر جدید، یک گروه با همان نام کاربر نیز به طور خودکار ایجاد می‌شود و GID آن گروه به طور منحصر به فرد به کاربر اختصاص داده می‌شود.

## انواع روش های اجرای کامند با دسترسی root

برای اجرای دستورات با دسترسی **root** در لینوکس، سه روش اصلی وجود دارد که هر کدام ویژگی‌ها و مزایای خاص خود را دارند. در اینجا به بررسی هر کدام از این روش‌ها و خطرات و مزایای آن‌ها می‌پردازیم:

1. **لاگین با استفاده از کاربر root**:

یکی از روش‌های ابتدایی برای دسترسی به سیستم به صورت کامل، **ورود به سیستم با حساب کاربری root** است. این روش به کاربر این امکان را می‌دهد که به تمام منابع و تنظیمات سیستم دسترسی داشته باشد.

با این حال، این روش بسیار خطرناک است و در بسیاری از **توزیع‌های لینوکس**، به دلایل امنیتی، **این امکان غیرفعال شده است**. دلیل اصلی این است که استفاده دائم از حساب root می‌تواند منجر به انجام اشتباهات یا اجرای دستورات مخرب شود، زیرا کاربر همیشه در حالت دسترسی کامل به سیستم است.

این روش معمولاً **برای مدیریت سیستم‌ها یا مشکلات خاص** استفاده می‌شود، اما توصیه نمی‌شود که به طور روزمره از آن استفاده کنید.

2. **استفاده از دستور `su`**:

دستور **`su`** که مخفف "substitute user" است، برای تغییر کاربر به کاربر دیگری استفاده می‌شود. به طور پیش‌فرض، اگر **هیچ آرگومانی به دستور وارد نشود**، این دستور کاربر را به کاربر root تغییر می‌دهد.

به این صورت، می‌توانید دستورات را به عنوان کاربر root اجرا کنید. بعد از وارد کردن دستور `su`، از شما خواسته می‌شود که **رمز عبور root** را وارد کنید تا وارد محیط کاربری root شوید.

این روش از نظر امنیتی به اندازه `sudo` امن نیست، زیرا پس از وارد کردن رمز عبور root، شما به طور کامل وارد محیط کاربری root می‌شوید و هر دستوری که وارد کنید به صورت مستقیم با دسترسی root اجرا می‌شود.

در صورتی که فراموش کنید از دستورات `exit` برای برگشت به حالت کاربری قبلی استفاده کنید، سیستم به حالت دسترسی root باقی می‌ماند.

3. **استفاده از دستور `sudo`**:

یکی از بهترین و امن‌ترین روش‌ها برای اجرای دستورات با دسترسی root، استفاده از **دستور `sudo`** است. دستور `sudo` به شما این امکان را می‌دهد که دستورات را به صورت موقت با دسترسی root اجرا کنید، اما به طور دائم وارد محیط root نمی‌شوید.

**نکته مهم** این است که هر بار که از `sudo` استفاده می‌کنید، **یک لاگ** در سیستم ثبت می‌شود که نشان می‌دهد کدام کاربر از این دستور استفاده کرده است. این ویژگی به مدیران سیستم کمک می‌کند تا ردیابی کنند که چه کسی و چه زمانی دستورات root را اجرا کرده است.

برای استفاده از `sudo`، کاربر باید در **فایل `sudoers`** تعریف شده باشد و به آن اجازه داده شود که دستورات را با دسترسی root اجرا کند.

این روش مشابه با دستور **"Run as Administrator"** در سیستم‌عامل ویندوز است. یعنی وقتی از `sudo` استفاده می‌کنید، فقط برای اجرای همان دستور خاص دسترسی root به شما داده می‌شود و پس از اتمام دستور، به حالت کاربری عادی باز می‌گردید.

این روش بسیار امن‌تر از روش‌های قبلی است، زیرا برای اجرای هر دستور نیاز به تایید شما از طریق رمز عبور است و به شما دسترسی به محیط کامل root نمی‌دهد.

در اینجا توضیحات کامل درباره دستورات زیر آمده است:

### Command **`w`**

دستور `w` در لینوکس اطلاعات مربوط به کاربران وارد شده به سیستم را نمایش می‌دهد، به همراه زمان ورود آن‌ها و فعالیت‌های جاری آن‌ها.

**خروجی این دستور معمولاً شامل موارد زیر است:**

**نام کاربری**: نام کاربری که وارد سیستم شده است.

**tty**: شماره ترمینالی که کاربر از آن وارد شده است.

**from**: آدرس IP یا نام میزبان سیستم که کاربر از آنجا وارد شده است.

**زمان ورود**: زمانی که کاربر وارد سیستم شده است.

**زمان بی‌کاری**: مدت زمانی که کاربر هیچ فعالیتی نداشته است.

**فعالیت‌های جاری**: دستوری که کاربر در حال حاضر اجرا می‌کند (اگر دستوری در حال اجرا باشد).

**مثال:**

```bash
w
```

خروجی ممکن است به صورت زیر باشد:

```
10:32:51 up 5 days,  3:24,  3 users,  load average: 0.05, 0.09, 0.06
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU  WHAT
john     pts/0    192.168.1.1     09:12    2.00s  0.05s  0.01s  bash
alice    pts/1    192.168.1.2     09:15    1.00s  0.00s  0.00s  w
```

------

### Command  **`id`**

دستور `id` اطلاعات مربوط به شناسه‌های کاربری (UID) و گروهی (GID) کاربر فعلی یا کاربر مشخص شده را نمایش می‌دهد. این دستور شامل شناسه کاربری، شناسه‌های گروه و گروه‌های اضافی است که کاربر به آن‌ها تعلق دارد.

**خروجی این دستور معمولاً شامل موارد زیر است:**

**UID**: شناسه عددی کاربر.

**GID**: شناسه عددی گروه اصلی کاربر.

**گروه‌های اضافی**: گروه‌هایی که کاربر به آن‌ها اضافه شده است.

**مثال:**

```bash
id
```

خروجی ممکن است به صورت زیر باشد:

```
uid=1000(john) gid=1000(john) groups=1000(john),27(sudo)
```

------

### Command  **`who`**

دستور `who` اطلاعاتی درباره کاربران وارد شده به سیستم را نشان می‌دهد. این دستور نمایش می‌دهد که کدام کاربران در حال حاضر وارد سیستم هستند، کجا وارد شده‌اند و از چه ترمینالی به سیستم دسترسی دارند.

**خروجی معمولی شامل اطلاعات زیر است:**

**نام کاربری**: نام کاربری که وارد شده است.

**ترمینال**: شماره ترمینال یا پورت که از آن وارد شده است.

**زمان ورود**: زمانی که کاربر وارد سیستم شده است.

**نام میزبان**: نام میزبان یا آدرس IP سیستم.

**مثال:**

```bash
who
```

خروجی ممکن است به صورت زیر باشد:

```
john     tty1         2025-02-09 09:00 (:0)
alice    pts/0        2025-02-09 09:10 (192.168.1.2)
```

------

### Command  **`whoami`**

دستور `whoami` به سادگی نام کاربری فعلی که در حال حاضر وارد سیستم است را نمایش می‌دهد.

**مثال:**

```bash
whoami
```

خروجی ممکن است به صورت زیر باشد:

```
john
```

------

### Command  **`getent`**

دستور `getent` برای جستجو در پایگاه‌داده‌های مختلف سیستم استفاده می‌شود. این دستور می‌تواند برای جستجو در پایگاه‌داده‌هایی مانند `/etc/passwd` (برای اطلاعات کاربر)، `/etc/group` (برای گروه‌ها) یا حتی سرویس‌های شبکه مانند LDAP استفاده شود.

**مثال‌ها**:

نمایش اطلاعات کاربر 

```bash
getent passwd john
```

نمایش اطلاعات گروه 

```bash
getent group sudo
```

**خروجی این دستورات به این صورت خواهد بود:**

```
john:x:1000:1000:John Doe:/home/john:/bin/bash
```

و برای گروه:

```
sudo:x:27:john
```

------

### Command  **`pinky`**

دستور `pinky` یک نسخه کوچک‌تر و فشرده‌تر از دستور `who` است. این دستور اطلاعات مربوط به کاربران و وضعیت آن‌ها را در قالبی کوتاه‌تر و دقیق‌تر نمایش می‌دهد.

**مثال:**

```bash
pinky
```

خروجی ممکن است به صورت زیر باشد:

```
Login    Name       Tty      Idle  Login Time   Office     Office Phone
john     John Doe   tty1       2   Fri 09:12   (none)      (none)
```

------

### Command **`last`**

دستور `last` تاریخچه ورود و خروج کاربران به سیستم را از لاگ‌ها نشان می‌دهد. این دستور اطلاعات مربوط به هر ورود کاربر، زمان ورود، مدت زمان آنلاین بودن و ترمینال مورد استفاده را نمایش می‌دهد.

**مثال:**

```bash
last
```

خروجی ممکن است به صورت زیر باشد:

```
john     tty1         Fri Feb  9 09:00   still logged in
alice    pts/0        Fri Feb  9 09:10   gone - no logout
reboot   system boot  Fri Feb  9 09:00   still running
```

در این مثال، می‌بینیم که کاربر `john` هنوز وارد سیستم است و کاربر `alice` از سیستم خارج شده است.

#### Command `useradd`

دستور `useradd` در لینوکس برای **افزودن کاربر جدید** به سیستم استفاده می‌شود. این دستور معمولاً با دستور `adduser` که در برخی توزیع‌ها به عنوان رابط کاربری ساده‌تر ارائه شده است، معادل است. هر دو دستور مشابه عملکرد دارند و برای ایجاد یک حساب کاربری جدید به کار می‌روند. البته ممکن است در برخی توزیع‌ها تفاوت‌های جزئی در پیاده‌سازی این دو دستور وجود داشته باشد.

آپشن‌ها و پارامترهای `useradd`:

دستور `useradd` دارای تعدادی آپشن است که می‌توانید از آن‌ها برای پیکربندی دقیق‌تر حساب کاربری جدید استفاده کنید. در اینجا برخی از پرکاربردترین آپشن‌ها توضیح داده شده است:

**`-p`**:

این آپشن برای **تنظیم رمز عبور کاربر** استفاده می‌شود. مقدار این گزینه باید رمز عبوری رمزنگاری شده (در قالب هش) باشد.

به عنوان مثال:

```bash
useradd -p $(openssl passwd -1 password123) john
```

این دستور حساب کاربری `john` را ایجاد کرده و رمز عبور `password123` را برای آن تنظیم می‌کند.

**`-m`**:

این گزینه باعث می‌شود که دایرکتوری خانگی (home directory) برای کاربر جدید ایجاد شود.

به طور پیش‌فرض، وقتی کاربری را با دستور `useradd` ایجاد می‌کنید، دایرکتوری خانگی برای آن کاربر ساخته نمی‌شود، مگر اینکه از این آپشن استفاده کنید.

به عنوان مثال:

```bash
useradd -m john
```

این دستور یک حساب کاربری به نام `john` ایجاد می‌کند و دایرکتوری خانگی `/home/john` را برای او می‌سازد.

**`-c`**:

این گزینه برای **افزودن توضیح یا کامنت** به حساب کاربری استفاده می‌شود. معمولاً از آن برای درج اطلاعات اضافی مانند نام کامل کاربر یا اطلاعات مربوط به شغل استفاده می‌شود.

به عنوان مثال:

```bash
useradd -c "John Doe, Developer" john
```

این دستور یک حساب کاربری `john` ایجاد کرده و کامنت `"John Doe, Developer"` را به حساب کاربری اضافه می‌کند.

**`-u`**:

این گزینه برای **تنظیم شناسه کاربری (UID)** استفاده می‌شود. به طور پیش‌فرض، زمانی که کاربری را ایجاد می‌کنید، لینوکس به طور خودکار یک UID اختصاص می‌دهد، اما با استفاده از این آپشن می‌توانید UID خاصی برای کاربر تعیین کنید.

به عنوان مثال:

```bash
useradd -u 1500 john
```

این دستور حساب کاربری `john` را با UID `1500` ایجاد می‌کند.

**`-s`**:

این گزینه برای **تنظیم شل پیش‌فرض** برای کاربر استفاده می‌شود. معمولاً، شل پیش‌فرض `/bin/bash` است، اما می‌توانید آن را به شل دیگری مانند `/bin/zsh` تغییر دهید.

به عنوان مثال:

```bash
useradd -s /bin/zsh john
```

این دستور حساب کاربری `john` را ایجاد می‌کند و شل پیش‌فرض آن را به `/bin/zsh` تغییر می‌دهد.

**`-r`**:

این گزینه برای **ایجاد کاربر سیستم** (system user) استفاده می‌شود. کاربران سیستم معمولاً برای سرویس‌ها و برنامه‌های خاص استفاده می‌شوند و معمولاً نیازی به ورود به سیستم ندارند.

این کاربر به طور معمول گروهی به نام `nobody` دارد و دسترسی‌های محدودی دارد.

به عنوان مثال:

```bash
useradd -r mysql
```

این دستور یک حساب کاربری سیستم به نام `mysql` ایجاد می‌کند که معمولاً برای اجرای سرویس MySQL استفاده می‌شود.

------

**مثال کامل استفاده از دستور `useradd`**:

فرض کنید می‌خواهید یک کاربر جدید به نام `alice` ایجاد کنید، که:

دایرکتوری خانگی‌اش ایجاد شود.

توضیحی برای آن تنظیم کنید.

شناسه کاربری آن `1001` باشد.

شل پیش‌فرض آن `/bin/bash` باشد.

دستور مورد نظر به شکل زیر خواهد بود:

```bash
useradd -m -c "Alice, System Admin" -u 1001 -s /bin/bash alice
```

این دستور یک حساب کاربری جدید به نام `alice` با دایرکتوری خانگی، توضیح و UID خاص ایجاد می‌کند.

### `/etc/skel`

در لینوکس، دایرکتوری **`/etc/skel`** (یا "skeleton directory") یک دایرکتوری ویژه است که به عنوان الگوی (skeleton) برای ایجاد فایل‌های پیش‌فرض در دایرکتوری خانه (home directory) کاربران جدید استفاده می‌شود. زمانی که یک حساب کاربری جدید ایجاد می‌شود (با استفاده از دستورات مانند `useradd` یا `adduser`)، فایل‌ها و دایرکتوری‌های موجود در `/etc/skel` به دایرکتوری خانه آن کاربر جدید کپی می‌شود.

این فایل‌ها معمولاً شامل فایل‌های پیکربندی پیش‌فرض برای شل، ایمیل، و دیگر تنظیمات محیطی هستند که کاربر به طور خودکار از آن‌ها بهره‌برداری می‌کند.

در دایرکتوری `/etc/skel` معمولاً فایل‌های زیر یافت می‌شود:

**`.bashrc`**: فایل پیکربندی شل Bash که تنظیمات اولیه شل را تعریف می‌کند (مانند متغیرهای محیطی، دستورات پیش‌فرض و غیره).

**`.profile`**: فایل پیکربندی شل برای ورود (login shell) که در زمان ورود به سیستم بارگذاری می‌شود.

**`.bash_profile`**: مشابه `.profile` برای شل‌های Bash، این فایل در زمان ورود به سیستم برای تنظیمات محیطی و دیگر پیکربندی‌ها استفاده می‌شود.

**`README`**: ممکن است برای ارایه اطلاعات مربوط به نحوه استفاده یا قوانین سیستم در دایرکتوری خانه جدید قرار گیرد.

نحوه استفاده از `/etc/skel`:

زمانی که یک کاربر جدید ایجاد می‌شود، دستورات مانند `useradd` به طور خودکار فایل‌ها و دایرکتوری‌های موجود در `/etc/skel` را به دایرکتوری خانگی آن کاربر کپی می‌کنند.

برای مثال:

کاربر جدید به نام 

```
john
```

 ایجاد می‌شود:

```bash
useradd -m john
```

سپس فایل‌هایی که در `/etc/skel` قرار دارند (مانند `.bashrc` و `.profile`) به دایرکتوری خانه `/home/john` کپی می‌شوند.

مزایا:

**پیکربندی ساده برای کاربران جدید**: این امکان را فراهم می‌آورد که کاربران جدید به طور خودکار فایل‌های پیکربندی اولیه و تنظیمات محیطی را دریافت کنند.

**قابلیت شخصی‌سازی**: مدیران سیستم می‌توانند فایل‌های پیش‌فرض خود را در `/etc/skel` قرار دهند تا هر کاربر جدید با تنظیمات مد نظر آن‌ها شروع به کار کند.

**ایجاد استانداردها**: این روش به ایجاد استانداردهایی برای پیکربندی کاربران جدید کمک می‌کند، به ویژه در محیط‌های سازمانی.

#### /etc/login.defs

فایل **`/etc/login.defs`** یک فایل پیکربندی سیستمی در لینوکس است که **تنظیمات پیش‌فرض مربوط به ورود کاربران** و **مدیریت حساب‌ها** را مشخص می‌کند. این فایل هنگام ایجاد کاربران جدید و هنگام ورود به سیستم توسط برخی دستورات مانند `login`, `passwd`, `useradd`, `usermod` و `userdel` استفاده می‌شود.

------

**محتویات و پارامترهای مهم `/etc/login.defs`**

این فایل شامل مجموعه‌ای از **متغیرها و مقادیر پیش‌فرض** است که رفتار سیستم را در مورد کاربران کنترل می‌کنند. برخی از مهم‌ترین تنظیمات عبارت‌اند از:

🔹 **تنظیمات مربوط به محدوده UID و GID**

`UID_MIN` و `UID_MAX`
 🔹 حداقل و حداکثر **شناسه کاربری (UID)** برای کاربران معمولی را مشخص می‌کند.

```bash
UID_MIN 1000
UID_MAX 60000
```

**توضیح**:

معمولاً در لینوکس، UID کمتر از `1000` برای کاربران سیستمی (system users) و سرویس‌ها اختصاص داده می‌شود.

کاربران معمولی از `1000` به بالا تخصیص داده می‌شوند.

`GID_MIN` و `GID_MAX`

 🔹 محدوده شناسه گروه (GID) برای کاربران جدید را مشخص می‌کند.

```bash
GID_MIN 1000
GID_MAX 60000
```

**توضیح**:

گروه‌های سیستمی معمولاً GID کمتر از `1000` دارند.

گروه‌های کاربران معمولی از `1000` به بالا شروع می‌شوند.

------

🔹 **مدیریت رمزهای عبور**

`PASS_MAX_DAYS`
 🔹 **حداکثر تعداد روزهایی که یک رمز عبور معتبر است.**

```bash
PASS_MAX_DAYS 99999
```

**توضیح**:

مقدار `99999` به این معناست که رمز عبور هرگز منقضی نمی‌شود.

مقدار کمتر از `90` معمولاً در سیستم‌های امنیتی برای الزام تغییر رمز عبور توصیه می‌شود.

`PASS_MIN_DAYS`
 🔹 **حداقل تعداد روزهایی که کاربر باید قبل از تغییر رمز عبور صبر کند.**

```bash
PASS_MIN_DAYS 0
```

**توضیح**:

مقدار `0` به این معناست که کاربر می‌تواند در هر لحظه رمز عبور خود را تغییر دهد.

`PASS_WARN_AGE`
 🔹 **چند روز قبل از منقضی شدن رمز عبور به کاربر هشدار داده شود.**

```bash
PASS_WARN_AGE 7
```

**توضیح**:

مقدار `7` یعنی ۷ روز قبل از انقضای رمز عبور، سیستم به کاربر هشدار می‌دهد.

------

🔹 **مدیریت حساب کاربری**

`CREATE_HOME`
 🔹 **مشخص می‌کند که آیا هنگام ایجاد یک کاربر جدید، دایرکتوری `home` برای او ساخته شود یا نه.**

```bash
CREATE_HOME yes
```

**توضیح**:

مقدار `yes` یعنی هنگام اجرای `useradd -m username`، دایرکتوری `/home/username` به صورت خودکار ایجاد شود.

مقدار `no` یعنی دایرکتوری خانگی ایجاد نخواهد شد.

`USERGROUPS_ENAB`
 🔹 **تعیین می‌کند که آیا هنگام حذف یک کاربر، گروه خصوصی او هم حذف شود یا نه.**

```bash
USERGROUPS_ENAB yes
```

**توضیح**:

مقدار `yes` یعنی اگر گروهی به نام کاربر وجود داشته باشد و هیچ کاربر دیگری عضو آن نباشد، هنگام حذف کاربر، گروه او نیز حذف شود.

------

🔹 **تنظیمات مربوط به محدودیت‌ها**

`LOGIN_RETRIES`
 🔹 **تعداد تلاش‌های مجاز برای ورود ناموفق به سیستم را مشخص می‌کند.**

```bash
LOGIN_RETRIES 5
```

**توضیح**:

مقدار `5` یعنی اگر یک کاربر ۵ بار رمز عبور اشتباه وارد کند، دسترسی او برای مدتی محدود خواهد شد.

`LOGIN_TIMEOUT`
 🔹 **حداکثر زمانی که یک کاربر می‌تواند در صفحه ورود معطل بماند (بر حسب ثانیه).**

```bash
LOGIN_TIMEOUT 60
```

**توضیح**:

مقدار `60` یعنی اگر کاربر بعد از ۶۰ ثانیه هنوز وارد سیستم نشده باشد، ارتباط قطع خواهد شد.



#### Command `usermod`

دستور **`usermod`** در لینوکس برای **ویرایش و تغییر تنظیمات کاربران موجود** استفاده می‌شود. این دستور به مدیر سیستم امکان می‌دهد تا ویژگی‌های مختلف یک حساب کاربری، از جمله **نام کاربری، دایرکتوری خانه، گروه‌ها و UID** را تغییر دهد.

📌 **نکته:** برای استفاده از `usermod`، به **دسترسی ریشه (root) یا sudo** نیاز دارید.

------

## **آپشن‌های مهم `usermod`**

1️⃣ `-d`  (تغییر دایرکتوری خانه کاربر)

🔹 این آپشن دایرکتوری خانگی یک کاربر را به مسیر جدیدی تغییر می‌دهد.
 🔹 توجه داشته باشید که این دستور **فقط مسیر را تغییر می‌دهد و فایل‌های قدیمی را منتقل نمی‌کند.**

**📌 دستور:**

```bash
sudo usermod -d /new/home/dir username
```

**🔹 مثال:**

```bash
sudo usermod -d /home/new_john john
```

✅ حالا اگر کاربر `john` وارد سیستم شود، مسیر دایرکتوری خانه او `/home/new_john` خواهد بود.

------

2️⃣ `-m`  (انتقال فایل‌ها به دایرکتوری جدید)

🔹 این آپشن در کنار `-d` استفاده می‌شود و باعث **انتقال تمام محتویات دایرکتوری خانه قدیمی به مسیر جدید** می‌شود.

**📌 دستور:**

```bash
sudo usermod -d /home/new_john -m john
```

✅ این دستور **تمام فایل‌های قدیمی موجود در `/home/john` را به `/home/new_john` منتقل می‌کند.**

------

3️⃣ `-u`  (تغییر UID کاربر)

🔹 این گزینه **شناسه کاربری (User ID یا UID)** کاربر را تغییر می‌دهد.
 🔹 UID باید **منحصربه‌فرد** باشد و نباید با UIDهای دیگر در سیستم تداخل داشته باشد.

**📌 دستور:**

```bash
sudo usermod -u 1050 john
```

✅ این دستور UID کاربر `john` را به `1050` تغییر می‌دهد.

📌 **نکته:** اگر کاربر از قبل فایل‌هایی در سیستم داشته باشد، پس از تغییر UID، مالکیت فایل‌های قبلی او تغییر نمی‌کند و باید دستی اصلاح شوند:

```bash
sudo chown -R 1050:john /home/john
```

✅ این دستور تمام فایل‌های دایرکتوری خانه `john` را به UID جدید اختصاص می‌دهد.

------

4️⃣ `-aG`  (افزودن کاربر به گروه ثانویه)

🔹 این گزینه کاربر را به **یک یا چند گروه اضافه می‌کند** بدون اینکه از گروه‌های قبلی حذف شود.
 🔹 `-G` گروه‌های جدید را تعیین می‌کند و `-a` تضمین می‌کند که گروه‌های قبلی حفظ شوند.

**📌 دستور:**

```bash
sudo usermod -aG sudo,docker john
```

✅ این دستور `john` را به گروه‌های **`sudo` و `docker`** اضافه می‌کند، بدون اینکه او را از گروه‌های قبلی‌اش حذف کند.

📌 **نکته مهم:** اگر `-a` استفاده نشود، کاربر از گروه‌های قبلی حذف شده و فقط عضو گروه‌های جدید می‌شود.

------

5️⃣ `-l`  (تغییر نام کاربری)

🔹 این گزینه **نام کاربری یک کاربر را تغییر می‌دهد** اما مسیر دایرکتوری خانه او را تغییر نمی‌دهد.

**📌 دستور:**

```bash
sudo usermod -l new_username old_username
```

✅ این دستور نام کاربر را از `old_username` به `new_username` تغییر می‌دهد.

📌 **نکته:** اگر بخواهید دایرکتوری خانه کاربر را نیز تغییر دهید، باید از `-d` و `-m` نیز استفاده کنید:

```bash
sudo usermod -l new_username -d /home/new_username -m old_username
```

✅ این دستور علاوه بر تغییر نام کاربری، دایرکتوری خانه را نیز به `/home/new_username` منتقل می‌کند.

#### Command `passwd`

### **دستور `passwd` در لینوکس**

دستور **`passwd`** در لینوکس برای **تعیین یا تغییر رمز عبور کاربران** استفاده می‌شود. همچنین می‌توان با این دستور **حساب‌های کاربری را قفل (lock) یا باز (unlock) کرد.**

📌 **نکته:**

- کاربران عادی فقط می‌توانند **رمز عبور خودشان** را تغییر دهند.
- مدیر سیستم (`root`) می‌تواند **رمز عبور سایر کاربران** را تغییر داده یا حساب‌های کاربری را قفل/باز کند.

------

## **آپشن‌های مهم `passwd`**

**1️⃣ `-l` (قفل کردن حساب کاربری)**

🔹 این گزینه حساب کاربری را **قفل (Lock)** می‌کند، به این معنا که **کاربر دیگر نمی‌تواند با رمز عبور خود وارد سیستم شود.**

**📌 دستور:**

```bash
sudo passwd -l username
```

✅ این دستور **رمز عبور کاربر را غیرفعال می‌کند** و باعث می‌شود که خط مربوط به رمز عبور در `/etc/shadow` با یک `!` در ابتدای آن ذخیره شود.

📌 **مثال بررسی `/etc/shadow` قبل و بعد از قفل شدن حساب:**

```bash
cat /etc/shadow | grep username
```

🔹 **قبل از قفل شدن:**

```
username:$6$xyz12345...:19000:0:99999:7:::
```

🔹 **بعد از قفل شدن (`passwd -l username`):**

```
username:!$6$xyz12345...:19000:0:99999:7:::
```

✅ `!` در ابتدای رمز عبور نشان می‌دهد که حساب قفل شده است.

📌 **نکته:**

- کاربرانی که **بدون رمز عبور (SSH key یا سایر روش‌ها)** به سیستم متصل می‌شوند، همچنان می‌توانند وارد شوند.
- برای جلوگیری از ورود کاربر با هر روشی، باید حساب کاربری را **غیرفعال (disable) یا حذف (delete)** کرد.

------

**2️⃣ `-u` (باز کردن قفل حساب کاربری)**

🔹 این گزینه **قفل کاربر را باز (Unlock)** می‌کند و کاربر می‌تواند دوباره با رمز عبور قبلی خود وارد سیستم شود.

**📌 دستور:**

```bash
sudo passwd -u username
```

✅ این دستور `!` را از ابتدای رمز عبور در `/etc/shadow` حذف می‌کند و حساب کاربری را دوباره فعال می‌کند.

📌 **بررسی `/etc/shadow` بعد از باز شدن قفل:**

```bash
cat /etc/shadow | grep username
```

🔹 **بعد از اجرای `passwd -u username`**:

```
username:$6$xyz12345...:19000:0:99999:7:::
```

✅ حالا کاربر می‌تواند دوباره با رمز عبور خود وارد سیستم شود.

#### Command `chage`

دستور **`chage`** در لینوکس برای **مدیریت تاریخ انقضا و سیاست‌های تغییر رمز عبور کاربران** استفاده می‌شود. این دستور به مدیر سیستم کمک می‌کند تا **مدت اعتبار رمز عبور یک کاربر، حداقل و حداکثر زمان بین تغییر رمز و تاریخ انقضای حساب** را کنترل کند.

#### Command `userdel`

دستور **`userdel`** در لینوکس برای **حذف حساب‌های کاربری** از سیستم استفاده می‌شود. این دستور توسط **مدیر سیستم (`root`)** یا کاربرانی که دارای **دسترسی `sudo`** هستند اجرا می‌شود.

------

## **نحوه استفاده از `userdel`**

🔹 حذف یک کاربر از سیستم:

```bash
sudo userdel username
```

✅ این دستور، کاربر `username` را **از فایل `/etc/passwd` و `/etc/shadow` حذف می‌کند**، اما **فایل‌های کاربر را در سیستم نگه می‌دارد.**

------

## **آپشن مهم `-r` در `userdel`**

**1️⃣ `-r` (حذف کامل کاربر به همراه فایل‌هایش)**

🔹 این گزینه علاوه بر حذف کاربر، **تمام دایرکتوری `home` و ایمیل‌های وی را نیز حذف می‌کند.**

📌 **دستور:**

```bash
sudo userdel -r username
```

✅ این دستور:

 ✔ **حساب کاربری** را از سیستم حذف می‌کند.

 ✔ **دایرکتوری `home`** مربوط به کاربر را که معمولاً در مسیر `/home/username/` است، پاک می‌کند.

 ✔ **ایمیل‌های کاربر** را که در `/var/mail/username` ذخیره شده‌اند، حذف می‌کند.

 ✔ **ورودی کاربر را از `/etc/passwd` و `/etc/shadow` حذف می‌کند.**

------

## **مثال:**

🔹 ابتدا یک کاربر جدید ایجاد می‌کنیم:

```bash
sudo useradd -m testuser
```

🔹 بررسی می‌کنیم که دایرکتوری `home` کاربر وجود دارد:

```bash
ls -l /home/testuser
```

🔹 حالا کاربر را **بدون آپشن `-r` حذف می‌کنیم:**

```bash
sudo userdel testuser
```

✅ کاربر حذف شده، اما دایرکتوری `/home/testuser` هنوز وجود دارد.

🔹 حالا کاربر را **با گزینه `-r` حذف می‌کنیم:**

```bash
sudo userdel -r testuser
```

✅ دایرکتوری `/home/testuser/` و تمام داده‌های مربوط به کاربر نیز حذف می‌شوند.

------

## **نکات مهم هنگام استفاده از `userdel`**

**اگر کاربر در حال اجرا باشد، `userdel` ممکن است خطا دهد.**

 🔹 در این حالت باید ابتدا **پردازش‌های کاربر را متوقف کنید.**

```bash
sudo pkill -u username
sudo userdel -r username
```

**اگر کاربر در حال استفاده از `shell` باشد، حذف آن توصیه نمی‌شود.**
 🔹 بهتر است ابتدا `shell` کاربر را به `/sbin/nologin` تغییر دهید:

```bash
sudo usermod -s /sbin/nologin username
```

#### Command `addgroup`

دستور **`addgroup`** در لینوکس برای **ایجاد گروه‌های جدید** استفاده می‌شود. این دستور در **توزیع‌های مبتنی بر Debian (مانند Ubuntu)** استفاده می‌شود. در سایر توزیع‌ها مانند RHEL و CentOS معمولاً از **`groupadd`** استفاده می‌شود.

------

## **نحوه استفاده از `addgroup`**

1️⃣ **ایجاد یک گروه جدید**

```bash
sudo addgroup groupname
```

✅ گروهی به نام `groupname` در فایل `/etc/group` ایجاد می‌شود.

------

## **آپشن مهم `-g` در `addgroup`**

**2️⃣ `-g` (تعیین GID برای گروه جدید)**

🔹 با این گزینه می‌توان **یک مقدار مشخص برای شناسه گروه (GID)** تعیین کرد.

 🔹 اگر این مقدار تعیین نشود، سیستم به‌طور خودکار یک **GID یکتا** اختصاص می‌دهد.

📌 **دستور:**

```bash
sudo addgroup -g 5001 developers
```

✅ گروهی به نام **`developers`** با **GID برابر با `5001`** ایجاد می‌شود.

#### `/etc/gshadows`

فایل **`/etc/gshadow`** در لینوکس اطلاعات **گروه‌ها و پسوردهای مربوط به آن‌ها** را نگهداری می‌کند. این فایل **نسخه‌ی امن‌تر فایل `/etc/group`** محسوب می‌شود و فقط توسط کاربر **ریشه (`root`)** و کاربران با دسترسی ویژه قابل خواندن است.

✅ این فایل به کاربران اجازه می‌دهد **برای گروه‌ها پسورد تنظیم کنند** تا کاربران دیگر بتوانند به‌صورت دستی وارد گروه شوند.

------

## **🔹 ساختار فایل `/etc/gshadow`**

فایل `/etc/gshadow` دارای فرمت زیر است:

```plaintext
group_name:password:admin_users:member_users
```

| **فیلد**       | **توضیحات**                                                  |
| -------------- | ------------------------------------------------------------ |
| `group_name`   | نام گروه                                                     |
| `password`     | **پسورد رمزنگاری‌شده** گروه (اگر خالی باشد یعنی نیازی به پسورد ندارد) |
| `admin_users`  | لیست کاربرانی که **دسترسی مدیریت** گروه را دارند             |
| `member_users` | لیست کاربران **عادی** گروه                                   |

خواهش می‌کنم! هیچ مشکلی نیست، خوشحال می‌شوم که کمک کنم! 😊

#### Command `groupmod`

دستور **`groupmod`** برای **ویرایش و تغییر ویژگی‌های گروه‌ها** در لینوکس استفاده می‌شود. این دستور به شما اجازه می‌دهد که **نام گروه، شناسه گروه (GID)** و دیگر تنظیمات گروه را تغییر دهید.

------

**🔹 نحوه استفاده از `groupmod`**

ساختار کلی دستور به این صورت است:

```bash
groupmod [گزینه‌ها] گروه
```

------

**🔹 آپشن‌های مهم `groupmod`**

| **آپشن** | **توضیحات**                                                  |
| -------- | ------------------------------------------------------------ |
| `-n`     | تغییر نام گروه. مثال: تغییر نام گروه از `old_group` به `new_group` |
| `-g`     | تغییر شناسه گروه (GID). مثال: تغییر GID گروه به `1001`       |
| `-o`     | اجازه می‌دهد که GID تکراری برای گروه انتخاب شود (توصیه نمی‌شود مگر در شرایط خاص) |
| `-p`     | تغییر پسورد گروه (هش‌شده).                                    |
| `-a`     | افزودن گروه به اعضای گروه‌های دیگر (در ترکیب با `-G`)         |
| `-G`     | تعیین گروه‌های اضافی برای گروه.                               |

**۱. تغییر نام گروه با `-n`**

اگر بخواهید نام یک گروه را تغییر دهید، مثلاً از `oldgroup` به `newgroup`:

```bash
sudo groupmod -n newgroup oldgroup
```

✅ این دستور نام گروه `oldgroup` را به `newgroup` تغییر می‌دهد.

**۲. تغییر شناسه گروه (GID) با `-g`**

اگر بخواهید شناسه گروه (`GID`) را تغییر دهید:

```bash
sudo groupmod -g 1001 mygroup
```

✅ این دستور `GID` گروه `mygroup` را به `1001` تغییر می‌دهد.

**۳. تغییر پسورد گروه با `-p`**

برای تغییر پسورد یک گروه (پسورد هش‌شده):

```bash
sudo groupmod -p '$6$somehashedpassword' mygroup
```

✅ این دستور پسورد گروه `mygroup` را به مقدار هش‌شده‌ی جدید تغییر می‌دهد.

**۴. افزودن گروه‌های اضافی با `-G`**

اگر بخواهید یک گروه را به چند گروه اضافی اضافه کنید:

```bash
sudo groupmod -G group1,group2 mygroup
```

✅ این دستور گروه `mygroup` را به گروه‌های `group1` و `group2` اضافه می‌کند.

------

**🔹 نکات مهم درباره `groupmod`**‏‏‏

تغییرات روی فایل‌های **`/etc/group`** و **`/etc/gshadow`** اعمال می‌شود.

در صورت تغییر **`GID`**، ممکن است دسترسی‌ها به فایل‌هایی که متعلق به گروه هستند تحت تاثیر قرار گیرد، بنابراین باید مراقب باشید.

برای اجرای دستور باید **دسترسی روت** داشته باشید.

# Ownership

در سیستم‌عامل لینوکس، هر عنصر موجود در سیستم، از جمله فایل‌ها، پوشه‌ها (دایرکتوری‌ها) و پردازش‌ها (پروسس‌ها)، دارای یک مالک مشخص است. این مالک می‌تواند کاربر خاصی از سیستم باشد و به‌طور پیش‌فرض، فردی که یک فایل یا فولدر را ایجاد می‌کند، به‌عنوان مالک آن در نظر گرفته می‌شود.

مالک یک فایل یا دایرکتوری دارای مجوزهای ویژه‌ای برای مدیریت آن است. این مجوزها شامل خواندن (Read)، نوشتن (Write) و اجرای (Execute) فایل می‌شود. در کنار مالکیت فردی، هر فایل و فولدر در لینوکس دارای یک گروه نیز هست که اعضای آن گروه می‌توانند بسته به سطح مجوزهای تنظیم‌شده، به فایل یا دایرکتوری دسترسی داشته باشند.

تغییر مالکیت یک فایل یا دایرکتوری در لینوکس فقط توسط کاربر **ریشه (root)** یا خود مالک اولیه امکان‌پذیر است. دستوراتی مانند `chown` (برای تغییر مالکیت) و `chgrp` (برای تغییر گروه مالکیت) برای این منظور استفاده می‌شوند. علاوه بر این، در برخی موارد، کاربرانی که دسترسی مدیریتی ویژه‌ای دارند (مثلاً از طریق دستور `sudo`)، می‌توانند مالکیت یک فایل یا پردازش را تغییر دهند.

#### Command `chown`

دستور `chown` (Change Owner) در لینوکس برای تغییر مالکیت یک فایل یا دایرکتوری استفاده می‌شود. این دستور به کاربر **ریشه (root)** یا کاربرانی که دارای مجوزهای مدیریتی (مثلاً با استفاده از `sudo`) هستند، امکان می‌دهد مالک یک فایل یا فولدر را تغییر دهند.

------

## **۱. ساختار کلی دستور `chown`**

```bash
chown [OPTIONS] NEW_OWNER[:NEW_GROUP] FILE...
```

`NEW_OWNER` → نام کاربر جدیدی که قرار است مالک فایل شود.

`NEW_GROUP` → (اختیاری) نام گروه جدیدی که قرار است گروه مالکیت فایل را تغییر دهد. اگر این مقدار مشخص نشود، فقط مالک تغییر می‌کند.

`FILE...` → نام یک یا چند فایل یا دایرکتوری که مالکیت آن‌ها تغییر می‌کند.

------

## **۲. مثال‌های عملی از `chown`**

**۱. تغییر مالک فایل به کاربر دیگر**

```bash
chown ali file.txt
```

این دستور، مالک فایل `file.txt` را به کاربر **ali** تغییر می‌دهد، اما گروه آن را تغییر نمی‌دهد.

------

**۲. تغییر مالک و گروه یک فایل**

```bash
chown ali:developers file.txt
```

در اینجا:

- مالک فایل `file.txt` به **ali** تغییر کرده است.
- گروه فایل به **developers** تغییر یافته است.

------

**۳. تغییر فقط گروه فایل بدون تغییر مالک**

```bash
chown :developers file.txt
```

در این حالت، فقط گروه فایل به **developers** تغییر می‌کند و مالک آن بدون تغییر باقی می‌ماند.

------

**۴. تغییر مالکیت برای چندین فایل**

```bash
chown ali file1.txt file2.txt file3.txt
```

این دستور، مالکیت فایل‌های `file1.txt`، `file2.txt` و `file3.txt` را به کاربر **ali** تغییر می‌دهد.

------

**۵. تغییر مالکیت دایرکتوری و همه فایل‌های درون آن**

```bash
chown -R ali:developers /home/ali
```

`-R` (یا `--recursive`) باعث می‌شود که این تغییرات به‌صورت بازگشتی (Recursive) روی همه فایل‌ها و دایرکتوری‌های داخل مسیر `/home/ali` اعمال شود.

یعنی تمام فایل‌ها و پوشه‌های داخل این دایرکتوری به کاربر **ali** و گروه **developers** تعلق خواهند گرفت.

#### Permissions

در سیستم‌عامل لینوکس، هر فایل و دایرکتوری دارای سه نوع دسته‌بندی کاربری است که بر اساس آن، سطوح دسترسی مختلفی تعیین می‌شود. این سه دسته شامل موارد زیر هستند:

**مالک (Owner):** کاربری که فایل یا دایرکتوری را ایجاد کرده است. این کاربر معمولاً دارای بیشترین سطح دسترسی است و می‌تواند مجوزهای فایل را تغییر دهد.

**گروه (Group):** هر فایل یا دایرکتوری به یک گروه خاص مرتبط است. کاربران عضو این گروه ممکن است بسته به سطح مجوزهای تعیین‌شده، اجازه خواندن، نوشتن یا اجرای فایل را داشته باشند.

**سایر کاربران (Others):** شامل تمام کاربرانی است که نه مالک فایل هستند و نه در گروه مالک آن عضو می‌باشند. این دسته معمولاً دارای کمترین سطح دسترسی است.

------

**سطوح دسترسی در لینوکس**

برای هر فایل یا دایرکتوری، سه نوع سطح دسترسی تعریف شده است که با مقادیر عددی مشخص می‌شوند:

| سطح دسترسی         | مقدار عددی | توضیح                                                        |
| ------------------ | ---------- | ------------------------------------------------------------ |
| **خواندن (Read)**  | `4`        | کاربر می‌تواند محتوای فایل را مشاهده کند یا لیست فایل‌های داخل یک دایرکتوری را ببیند. |
| **نوشتن (Write)**  | `2`        | کاربر می‌تواند محتوای فایل را تغییر دهد یا فایل‌های جدیدی در دایرکتوری ایجاد کند. |
| **اجرا (Execute)** | `1`        | کاربر می‌تواند یک فایل اجرایی را اجرا کند یا وارد یک دایرکتوری شود. |

### Command `ls -l`

```bash
ls -l
```

🔹 خروجی نمونه:

```
-rw-r--r--  1 user group  1234 Feb 11 12:30 file.txt
drwxr-xr-x  2 user group  4096 Feb 10 10:00 my_directory
```

**🔍 اجزای این خروجی به ترتیب از چپ به راست:**

| شماره | **بخش**                 | **مثال**       | **توضیح**                                                    |
| ----- | ----------------------- | -------------- | ------------------------------------------------------------ |
| 1️⃣     | **مجوزهای دسترسی**      | `-rw-r--r--`   | مجوز خواندن (`r`)، نوشتن (`w`)، اجرا (`x`) برای مالک، گروه، و سایر کاربران. |
| 2️⃣     | **تعداد لینک‌ها**        | `1`            | تعداد لینک‌های سخت (Hard Links) به این فایل.                  |
| 3️⃣     | **مالک (User)**         | `user`         | نام کاربری مالک فایل.                                        |
| 4️⃣     | **گروه (Group)**        | `group`        | نام گروهی که به فایل دسترسی دارد.                            |
| 5️⃣     | **اندازه فایل (Bytes)** | `1234`         | اندازه فایل (بر حسب بایت).                                   |
| 6️⃣     | **تاریخ آخرین تغییر**   | `Feb 11 12:30` | آخرین زمان تغییر فایل.                                       |
| 7️⃣     | **نام فایل/دایرکتوری**  | `file.txt`     | نام فایل یا دایرکتوری                                        |

### Command `chmod`

دستور `chmod` (Change Mode) در لینوکس برای **تغییر سطح دسترسی** (Permissions) فایل‌ها و دایرکتوری‌ها استفاده می‌شود. این دستور به کاربر امکان می‌دهد مجوزهای **خواندن (Read - `r`)، نوشتن (Write - `w`) و اجرا (Execute - `x`)** را برای **مالک، گروه و سایر کاربران** تنظیم کند.

------

## **۱. ساختار کلی دستور `chmod`**

```bash
chmod [OPTIONS] MODE FILE...
```

**`MODE`**: تعیین سطح دسترسی (به‌صورت عددی یا نمادی)

**`FILE...`**: نام یک یا چند فایل یا دایرکتوری که قرار است مجوزهای آن تغییر کند

**`OPTIONS`**: شامل گزینه‌های اضافی مثل `-R` برای تغییرات بازگشتی (Recursive)

------

## ** تعیین سطح دسترسی با `chmod` (روش عددی – Octal Mode)**

در روش **عددی**، هر سطح دسترسی با یک عدد **سه‌رقمی** نمایش داده می‌شود.

| سطح دسترسی | عدد معادل | توضیح                                            |
| ---------- | --------- | ------------------------------------------------ |
| r          | `4`       | مشاهده محتوا                                     |
| w          | `2`       | ویرایش و تغییر محتوا                             |
| x          | `1`       | اجرای فایل یا ورود به دایرکتوری                  |
| t          | `1`       | در صورت استفاده از این گزینه، مجوز 4 رقمی می شود |
| s          | `2`       | SUID                                             |
| s          | `4`       | GUID                                             |

```bash
chmod 744 file.txt
```

**`7`** → مالک: خواندن (`4`) + نوشتن (`2`) + اجرا (`1`) = `7` (rwx)

**`4`** → گروه: فقط خواندن (`4`)

**`4`** → سایر کاربران: فقط خواندن (`4`)

اگر بخواهیم سطح دسترسی تمام فایل‌ها و زیرپوشه‌های داخل یک دایرکتوری را تغییر دهیم، از `-R` استفاده می‌کنیم:

```
chmod -R 755 /var/www/html
```

** نکات مهم درباره `chmod`**

**فقط مالک فایل یا کاربر `root` می‌تواند سطح دسترسی را تغییر دهد.**

**به `777` دادن دقت کنید!** این مقدار به همه کاربران اجازه تغییر فایل را می‌دهد که می‌تواند خطر امنیتی باشد.

برای اسکریپت‌های اجرایی، حداقل سطح دسترسی باید `755` باشد.

## **✅ ساختار کلی `chmod` به روش Symbolic**

```bash
chmod [چه کسی] [عملیات] [مجوز] file_or_directory
```

🔹 ساختار دستورات:

```bash
chmod [user/group/others] [+/-/=] [r/w/x] file
```

------

## **✅ تعیین "چه کسی" (User, Group, Others)**

| **حرف** | **نماینده**               | **توضیح**                           |
| ------- | ------------------------- | ----------------------------------- |
| `u`     | **User (مالک)**           | مالک فایل (کسی که فایل را ساخته)    |
| `g`     | **Group (گروه)**          | گروهی که فایل به آن اختصاص داده شده |
| `o`     | **Others (سایر کاربران)** | همه کاربران دیگر در سیستم           |
| `a`     | **All (همه کاربران)**     | ترکیب `u`, `g`, `o` معادل `ugo`     |

------

## **✅ تعیین "عملیات"**

| **نماد** | **عملکرد**      | **توضیح**                                          |
| -------- | --------------- | -------------------------------------------------- |
| `+`      | **افزودن مجوز** | اجازه دسترسی را اضافه می‌کند.                       |
| `-`      | **حذف مجوز**    | اجازه دسترسی را حذف می‌کند.                         |
| `=`      | **تنظیم مجوز**  | فقط همین مجوزها را تنظیم کرده و بقیه را حذف می‌کند. |

------

## **✅ مثال‌های کاربردی**

**1️⃣ دادن دسترسی خواندن و نوشتن به مالک (User)**

```bash
chmod u+rw file.txt
```

🔹 **مالک فایل** می‌تواند **بخواند (`r`) و بنویسد (`w`)**.
 🔹 سایرین بدون تغییر می‌مانند.

------

**2️⃣ حذف مجوز نوشتن از گروه و سایر کاربران**

```bash
chmod go-w file.txt
```

🔹 گروه (`g`) و سایر کاربران (`o`) دیگر **اجازه ویرایش (`w`) فایل را ندارند**.

------

**3️⃣ تنظیم مجوزهای کامل فقط برای مالک**

```bash
chmod u=rwx,go= file.txt
```

🔹 **مالک** می‌تواند **بخواند، بنویسد و اجرا کند (`rwx`)**.
 🔹 **گروه (`g`) و سایر کاربران (`o`) هیچ مجوزی ندارند**.

------

**4️⃣ دادن اجازه اجرا به همه کاربران**

```bash
chmod a+x script.sh
```

🔹 حالا **همه (`a`) می‌توانند این اسکریپت را اجرا کنند**.

------

**5️⃣ حذف همه مجوزها از سایر کاربران**

```bash
chmod o-rwx file.txt
```

🔹 **سایر کاربران (`o`) نمی‌توانند فایل را بخوانند (`r`)، بنویسند (`w`) یا اجرا کنند (`x`)**.

------

**6️⃣ دادن مجوز کامل به مالک و فقط مجوز خواندن به بقیه**

```bash
chmod u=rwx,go=r file.txt
```

🔹 مالک (`u`) می‌تواند بخواند، بنویسد و اجرا کند (`rwx`).
 🔹 گروه (`g`) و سایر کاربران (`o`) فقط می‌توانند **بخوانند (`r`)**.

------

**✅ ترکیب چندین تغییر در یک دستور**

```bash
chmod u+rwx,g-w,o-r file.txt
```

🔹 این دستور **چندین تغییر را هم‌زمان اعمال می‌کند**:
 1️⃣ به **مالک (`u`)** دسترسی **خواندن، نوشتن و اجرا (`+rwx`)** داده می‌شود.
 2️⃣ از **گروه (`g`)** دسترسی **نوشتن (`-w`)** گرفته می‌شود.
 3️⃣ از **سایر کاربران (`o`)** دسترسی **خواندن (`-r`)** گرفته می‌شود.

## تفاوت بین دایرکتوری و فایل درمجوزها

در لینوکس، دایرکتوری‌ها نیز مانند فایل‌ها دارای مجوزهای دسترسی هستند، اما نحوه اعمال این مجوزها کمی متفاوت است. در ادامه، نکات مهمی که باید در مورد سطح دسترسی دایرکتوری‌ها بدانید، بررسی می‌شود:

------

**۱. تفاوت مجوزهای `r`, `w` و `x` در دایرکتوری‌ها**

| سطح دسترسی         | نماد | تأثیر در دایرکتوری                                         |
| ------------------ | ---- | ---------------------------------------------------------- |
| **خواندن (Read)**  | `r`  | امکان مشاهده لیست فایل‌های داخل دایرکتوری                   |
| **نوشتن (Write)**  | `w`  | امکان ایجاد، حذف یا تغییر نام فایل‌ها (به شرط داشتن `x` هم) |
| **اجرا (Execute)** | `x`  | امکان ورود (`cd`) به دایرکتوری و دسترسی به فایل‌های داخل آن |

**توضیح مهم درباره `x` در دایرکتوری‌ها**

اگر **`r` بدون `x`** باشد، نمی‌توان داخل دایرکتوری رفت ولی می‌توان لیست فایل‌های آن را مشاهده کرد.

اگر **`x` بدون `r`** باشد، می‌توان وارد دایرکتوری شد اما نام فایل‌ها را نمی‌توان دید (مگر اینکه نام دقیقشان را بدانید).

------

**۲. تنظیم مجوزهای استاندارد برای دایرکتوری‌ها**

در عمل، سطح دسترسی استاندارد برای دایرکتوری‌ها معمولاً یکی از موارد زیر است:

| مقدار عددی | توضیح                                                        |
| ---------- | ------------------------------------------------------------ |
| **`755`**  | مالک می‌تواند بخواند، بنویسد و وارد دایرکتوری شود. گروه و سایر کاربران فقط می‌توانند وارد شوند و فایل‌ها را مشاهده کنند. |
| **`700`**  | فقط مالک می‌تواند وارد دایرکتوری شود، فایل‌ها را مشاهده و ویرایش کند. سایر کاربران هیچ دسترسی ندارند. |
| **`777`**  | همه می‌توانند فایل‌ها را ببینند، تغییر دهند و وارد دایرکتوری شوند (غیرامن و خطرناک). |

**مثال‌های تنظیم مجوز**

دسترسی خواندن و ورود به دایرکتوری برای همه کاربران:

```bash
chmod 755 mydir
```

محدود کردن دسترسی فقط به مالک:

```bash
chmod 700 private_folder
```

------

**۳. `w` روی دایرکتوری چطور کار می‌کند؟**

اگر کاربری روی یک دایرکتوری مجوز **`w` (نوشتن)** داشته باشد:
 ✅ می‌تواند فایل‌هایی را درون آن ایجاد یا حذف کند.
 ✅ می‌تواند فایل‌های موجود را تغییر نام دهد.

🚨 **اما این مجوز روی فایل‌های داخل دایرکتوری تأثیر ندارد!** اگر یک فایل داخل این دایرکتوری باشد که فقط مجوز خواندن دارد (`r--`)، حتی با داشتن مجوز `w` روی دایرکتوری، کاربر نمی‌تواند آن را ویرایش کند. اما **می‌تواند آن را حذف کند**، چون اجازه نوشتن در **خود دایرکتوری** دارد.

**مثال:**

```bash
chmod 777 /shared_folder
```

همه کاربران می‌توانند فایل ایجاد کنند و حتی فایل‌های دیگران را حذف کنند، بدون توجه به مجوزهای فایل!

🚨 **به همین دلیل، مجوز `777` روی دایرکتوری‌ها خطرناک است.** بهتر است از `775` یا `755` استفاده شود.

#### **🔹  `sticky bit`, `SUID`, `SGID`**

در لینوکس، این سه مفهوم به سطح دسترسی **ویژه** تعلق دارند که رفتار فایل‌ها و دایرکتوری‌ها را تغییر می‌دهند. هرکدام نقش خاصی در امنیت و مدیریت دسترسی دارند.

| **ویژگی**                | **مقدار عددی** | **کاربرد**                    | **توضیح**                                                    |
| ------------------------ | -------------- | ----------------------------- | ------------------------------------------------------------ |
| **Sticky Bit** (`t`)     | `1`            | دایرکتوری‌های عمومی مثل `/tmp` | مانع از حذف فایل‌های دیگران در یک دایرکتوری می‌شود، مگر توسط مالک یا `root`. |
| **SUID** (`s` برای مالک) | `2`            | فایل‌های اجرایی                | برنامه با **مجوزهای مالک فایل** اجرا می‌شود، نه مجوزهای کاربر اجرا‌کننده. |
| **SGID** (`s` برای گروه) | `4`            | فایل‌های اجرایی و دایرکتوری‌ها  | 1️⃣ اجرای فایل با **مجوزهای گروه مالک**. 2️⃣ همه فایل‌های جدید در یک دایرکتوری، به **همان گروه دایرکتوری** اختصاص می‌یابند. |

------

**📌 نحوه ترکیب مقادیر**

این ویژگی‌ها را می‌توان با هم ترکیب کرد. مقدار نهایی را با جمع کردن اعداد به‌دست می‌آوریم:

| **ویژگی‌ها**                  | **مقدار نهایی** | **مثال `chmod`**    |
| ---------------------------- | --------------- | ------------------- |
| **فقط Sticky Bit**           | `1000`          | `chmod 1000 folder` |
| **فقط SUID**                 | `2000`          | `chmod 2000 file`   |
| **فقط SGID**                 | `4000`          | `chmod 4000 file`   |
| **SUID + SGID**              | `6000`          | `chmod 6000 file`   |
| **SGID + Sticky Bit**        | `5000`          | `chmod 5000 folder` |
| **SUID + Sticky Bit**        | `3000`          | `chmod 3000 file`   |
| **SUID + SGID + Sticky Bit** | `7000`          | `chmod 7000 file`   |

------

**1️⃣ Sticky Bit (`t`) – جلوگیری از حذف فایل‌های دیگران**

**🔹 توضیح:**
 Sticky Bit روی دایرکتوری‌هایی که چندین کاربر به آن‌ها دسترسی دارند (مثلاً `/tmp`) تنظیم می‌شود و **مانع از حذف فایل‌های دیگران توسط کاربران معمولی** می‌شود.

**🔹 بدون Sticky Bit:** هر کسی که روی یک دایرکتوری **مجوز نوشتن (`w`)** دارد، می‌تواند فایل‌های دیگران را حذف کند!

 **🔹 با Sticky Bit:** فقط **مالک فایل** و **مدیر (`root`)** می‌توانند فایل‌ها را حذف کنند.

**✅ نحوه تنظیم Sticky Bit**

```bash
chmod +t /shared_folder
```

🔹 این دستور `sticky bit` را روی **`/shared_folder`** فعال می‌کند.

**🔍 بررسی `sticky bit` در مجوزهای دایرکتوری**

```bash
ls -ld /shared_folder
```

🔹 خروجی نمونه:

```
drwxrwxrwt 10 root users 4096 Feb 11 10:00 /shared_folder
```

🔹 `t` در انتهای `drwxrwxrwt` نشان‌دهنده فعال بودن Sticky Bit است.

**2️⃣ SUID (Set User ID) – اجرای برنامه با مجوزهای مالک فایل**

**🔹 توضیح:**
 SUID به **فایل‌های اجرایی** اعمال می‌شود و باعث می‌شود که وقتی یک کاربر معمولی برنامه‌ای را اجرا می‌کند، آن برنامه با مجوزهای **مالک فایل** اجرا شود، نه مجوزهای خود کاربر!

**✅ مثال معروف: `passwd`**

```bash
ls -l /usr/bin/passwd
```

🔹 خروجی:

```
-rwsr-xr-x 1 root root 54232 Feb 11 10:00 /usr/bin/passwd
```

🔹 `s` در `-rwsr-xr-x` نشان‌دهنده **SUID** است.

وقتی یک کاربر معمولی دستور `passwd` را اجرا می‌کند، این برنامه با **مجوزهای `root`** اجرا می‌شود، تا بتواند رمز عبور را تغییر دهد، حتی اگر کاربر معمولی دسترسی نوشتن به `/etc/shadow` نداشته باشد.

**✅ تنظیم `SUID` روی یک برنامه**

```bash
chmod u+s myscript.sh
```

🔹 این دستور `SUID` را روی `myscript.sh` فعال می‌کند.

**🔍 بررسی `SUID` در مجوزها**

```bash
ls -l myscript.sh
```

🔹 خروجی:

```
-rwsr-xr-x 1 root root 1234 Feb 11 10:00 myscript.sh
```

🔹 `s` در جای `x` مالک (`rws`) نشان‌دهنده فعال بودن `SUID` است.

**❌ خطرات امنیتی `SUID`**

🚨 اگر `SUID` روی برنامه‌ای تنظیم شود که دارای **باگ‌های امنیتی** باشد، یک کاربر معمولی ممکن است بتواند سطح دسترسی خودش را بالا ببرد و سیستم را هک کند! به همین دلیل، این قابلیت فقط باید روی برنامه‌های **معتبر و ضروری** تنظیم شود.

------

**😂 جوک درباره `SUID`**

👨‍💻 **ادمین:** "کدوم کاربر رمز عبورش رو بدون مجوز عوض کرده؟!"
 👩‍💻 **کاربر:** "خب دستور `passwd` زدم، همین که باید اجرا شه، نه؟!"
 👨‍💻 **ادمین:** "آره، ولی همین `SUID` باعث شد که این کارو بدون مجوز واقعی انجام بدی! جادوی لینوکس!" 😂

------

**3️⃣ SGID (Set Group ID) – اجرای برنامه یا ایجاد فایل با گروه مشخص**

**🔹 توضیح:**
 SGID دو کاربرد اصلی دارد:

1. **روی فایل‌های اجرایی:** وقتی یک برنامه با `SGID` اجرا شود، با **مجوزهای گروه مالک آن فایل** اجرا می‌شود.
2. **روی دایرکتوری‌ها:** تمام فایل‌هایی که داخل دایرکتوری دارای `SGID` ایجاد شوند، به‌طور خودکار به **همان گروه** اختصاص داده می‌شوند، حتی اگر کاربر دیگری آن‌ها را بسازد!

------

**✅ مثال اول: `SGID` روی فایل اجرایی**

```bash
chmod g+s myprogram
```

🔹 حالا اگر کاربری این برنامه را اجرا کند، با مجوزهای **گروه مالک** اجرا می‌شود.

بررسی سطح دسترسی:

```bash
ls -l myprogram
```

🔹 خروجی:

```
-rwxr-sr-x 1 root devs 54232 Feb 11 10:00 myprogram
```

🔹 `s` در ستون مجوزهای گروه (`r-s`) نشان‌دهنده **SGID** است.

------

**✅ مثال دوم: `SGID` روی دایرکتوری**

```bash
chmod g+s /shared_folder
```

🔹 حالا هر فایلی که در `/shared_folder` ایجاد شود، به **گروه مالک آن دایرکتوری** تعلق خواهد داشت، حتی اگر سازنده فایل در گروه دیگری باشد.

بررسی سطح دسترسی:

```bash
ls -ld /shared_folder
```

🔹 خروجی:

```
drwxr-sr-x 10 root developers 4096 Feb 11 10:00 /shared_folder
```

🔹 `s` در ستون گروه (`r-s`) نشان‌دهنده فعال بودن **SGID** است.

#### Command `umask`

**`umask` در لینوکس** مقدار پیش‌فرضی است که تعیین می‌کند چه مجوزهایی نباید به فایل‌ها و دایرکتوری‌های جدید اختصاص داده شوند. این مقدار از مجوزهای پیش‌فرض کم می‌شود.



